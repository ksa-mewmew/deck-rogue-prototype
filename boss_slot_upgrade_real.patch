diff -ruN /src/engine/combat/intents.ts /src/engine/combat/intents.ts
--- /src/engine/combat/intents.ts	2026-02-23 14:36:44.000000000 +0000
+++ /src/engine/combat/intents.ts	2026-02-24 11:59:22.425084777 +0000
@@ -1,205 +1,214 @@
-import type { GameState } from "../types";
-import { aliveEnemies, logMsg, pickOne } from "../rules";
-import { runRelicHook } from "../relics";
-import { buildIntentPreview } from "../intentPreview";
-
-const NO_REPEAT_INTENT_INDEXES: Record<string, ReadonlySet<number>> = {
-  other_adventurer: new Set([1]),
-  slime: new Set([0, 1]),
-  pebble_golem: new Set([1]),
-  rock_golem: new Set([1]),
-  poison_spider: new Set([0, 2]),
-  boss_cursed_wall: new Set([0]),
-  boss_giant_orc: new Set([1]),
-};
-
-function shouldBlockRepeatByIndex(enemyId: string, intentIndex: number) {
-  const s = NO_REPEAT_INTENT_INDEXES[enemyId];
-  return !!s && s.has(intentIndex);
-}
-
-function stableStringify(v: any): string {
-  if (v === null) return "null";
-  const t = typeof v;
-  if (t === "number" || t === "boolean") return String(v);
-  if (t === "string") return JSON.stringify(v);
-  if (Array.isArray(v)) return "[" + v.map(stableStringify).join(",") + "]";
-  if (t === "object") {
-    const keys = Object.keys(v).sort();
-    return "{" + keys.map((k) => JSON.stringify(k) + ":" + stableStringify(v[k])).join(",") + "}";
-  }
-  return JSON.stringify(String(v));
-}
-
-function intentActionKey(intent: any): string {
-  if (!intent) return "NONE";
-  const clone: any = {};
-  for (const k of Object.keys(intent)) {
-    if (k === "label" || k === "text" || k === "desc" || k === "name") continue;
-    clone[k] = intent[k];
-  }
-  if (clone.effects && Array.isArray(clone.effects)) {
-    clone.effects = clone.effects.map((e: any) => {
-      const ec: any = {};
-      for (const kk of Object.keys(e ?? {})) {
-        if (kk === "label" || kk === "text" || kk === "desc" || kk === "name") continue;
-        ec[kk] = e[kk];
-      }
-      return ec;
-    });
-  }
-  return stableStringify(clone);
-}
-
-function commitIntentHistory(e: any, key: string) {
-  const lastKey: string | null = e.lastIntentKey ?? null;
-  const streak: number = e.lastIntentStreak ?? 0;
-  if (lastKey === key) {
-    e.lastIntentStreak = Math.min(3, streak + 1);
-  } else {
-    e.lastIntentKey = key;
-    e.lastIntentStreak = 1;
-  }
-}
-
-function pickNextIntentIndex(intents: any[], lastIndex: number, enemyId: string, lastKey: string | null, streak: number) {
-  const n = intents.length;
-  if (n <= 1) return 0;
-
-  const candidates = Array.from({ length: n }, (_, i) => i);
-
-  const block2 = (ix: number) => ix === lastIndex && shouldBlockRepeatByIndex(enemyId, ix);
-  const block3 = (ix: number) => !!lastKey && streak >= 2 && intentActionKey(intents[ix]) === lastKey;
-
-  const both = candidates.filter((ix) => !block2(ix) && !block3(ix));
-  if (both.length > 0) return pickOne(both);
-
-  const onlyNo3 = candidates.filter((ix) => !block3(ix));
-  if (onlyNo3.length > 0) return pickOne(onlyNo3);
-
-  const onlyNo2 = candidates.filter((ix) => !block2(ix));
-  if (onlyNo2.length > 0) return pickOne(onlyNo2);
-
-  return pickOne(candidates);
-}
-
-function getCombatDeckSize(g: GameState): number {
-  return (
-    g.deck.length +
-    g.hand.length +
-    g.discard.length +
-    g.frontSlots.filter(Boolean).length +
-    g.backSlots.filter(Boolean).length +
-    g.exhausted.length
-  );
-}
-
-function calcDeckSizeDamage(act: { base: number; per: number; div: number; cap?: number }, deckSize: number) {
-  const scale = Math.ceil(deckSize / act.div);
-  let dmg = act.base + act.per * scale;
-  if (act.cap != null) dmg = Math.min(dmg, act.cap);
-  return { dmg, scale };
-}
-
-const SOUL_WARN_INTENT_INDEX = 2;
-const SOUL_NUKE_CHANCE = 0.6;
-
-export function revealIntentsAndDisrupt(g: GameState) {
-  if (g.intentsRevealedThisTurn) return;
-  g.intentsRevealedThisTurn = true;
-
-  g.attackedEnemyIndicesThisTurn = [];
-  g.backUidsThisTurn = [];
-  g.placedUidsThisTurn = [];
-  g.drawCountThisTurn = 0;
-
-  g.phase = "REVEAL";
-
-  g.player.immuneToDisruptThisTurn = false;
-  g.player.nullifyDamageThisTurn = false;
-
-  g.disruptIndexThisTurn = null;
-  g.backSlotDisabled = [false, false, false];
-
-  const disrupt = g.player.status.disrupt ?? 0;
-  if (disrupt > 0) {
-    g.disruptIndexThisTurn = Math.floor(Math.random() * 3);
-    g.backSlotDisabled[g.disruptIndexThisTurn] = true;
-  }
-
-  for (const e of g.enemies) {
-    e.immuneThisTurn = e.immuneNextTurn;
-    e.immuneNextTurn = false;
-  }
-
-  for (const e of aliveEnemies(g)) {
-    e.intentLabelOverride = undefined;
-
-    const def = g.content.enemiesById[e.id];
-    const intents = def.intents;
-    if (!intents || intents.length === 0) continue;
-
-    const nextIx = pickNextIntentIndex(
-      intents,
-      e.intentIndex ?? 0,
-      e.id,
-      e.lastIntentKey ?? null,
-      e.lastIntentStreak ?? 0
-    );
-
-    e.intentIndex = nextIx;
-
-    const picked = intents[nextIx % intents.length];
-    commitIntentHistory(e, intentActionKey(picked));
-
-    if (e.id === "boss_soul_stealer") {
-      e.soulWillNukeThisTurn = false;
-      const warn = e.soulWarnCount ?? 0;
-      const armed = !!e.soulArmed;
-
-      if (armed) {
-        if (Math.random() < SOUL_NUKE_CHANCE) {
-          e.soulWillNukeThisTurn = true;
-          e.intentLabelOverride = "Ï¢ÖÎßê: 50 ÌîºÌï¥";
-          logMsg(g, `Ï†Å ÏùòÎèÑ: ${e.name} ‚Üí ${e.intentLabelOverride}`);
-          continue;
-        }
-        const it = intents[e.intentIndex % intents.length];
-        e.intentLabelOverride = `${it.label} (Ìè≠Î∞ú Í∞ÄÎä• ÏÉÅÌÉú)`;
-        logMsg(g, `Ï†Å ÏùòÎèÑ: ${e.name} ‚Üí ${e.intentLabelOverride}`);
-        continue;
-      }
-
-      const it = intents[e.intentIndex % intents.length];
-      e.intentLabelOverride = `${it.label} (Í≤ΩÍ≥† ${warn}/3)`;
-      logMsg(g, `Ï†Å ÏùòÎèÑ: ${e.name} ‚Üí ${e.intentLabelOverride}`);
-      continue;
-    }
-
-    const intent = intents[e.intentIndex % intents.length];
-
-    const p = buildIntentPreview(g, e, intent);
-
-    let suffix = "";
-    if (p.dmgTotal != null) {
-      suffix = (p.hits ?? 1) > 1 ? ` (${p.dmgTotal}, ${p.hits}ÌÉÄ)` : ` (${p.dmgTotal})`;
-    } else if ((p.hits ?? 0) > 1) {
-      suffix = ` (${p.hits}ÌÉÄ)`;
-    }
-
-    const label = `${intent.label}${suffix}`;
-
-    e.intentLabelOverride = label;
-    logMsg(g, `Ï†Å ÏùòÎèÑ: ${e.name} ‚Üí ${label}`);
-  }
-
-  if (g.disruptIndexThisTurn !== null) {
-    logMsg(g, `ÍµêÎûÄ: Ïù¥Î≤à ÌÑ¥ ÌõÑÏó¥ ${g.disruptIndexThisTurn} Î¨¥Ìö®`);
-  }
-
-  runRelicHook(g, "onReveal");
-
-  g.phase = "PLACE";
-}
-
-export const __SOUL_WARN_INTENT_INDEX = SOUL_WARN_INTENT_INDEX;
+import type { GameState } from "../types";
+import { aliveEnemies, logMsg, pickOne } from "../rules";
+import { runRelicHook } from "../relics";
+import { buildIntentPreview } from "../intentPreview";
+
+const NO_REPEAT_INTENT_INDEXES: Record<string, ReadonlySet<number>> = {
+  other_adventurer: new Set([1]),
+  slime: new Set([0, 1]),
+  pebble_golem: new Set([1]),
+  rock_golem: new Set([1]),
+  poison_spider: new Set([0, 2]),
+  boss_cursed_wall: new Set([0]),
+  boss_giant_orc: new Set([1]),
+};
+
+function shouldBlockRepeatByIndex(enemyId: string, intentIndex: number) {
+  const s = NO_REPEAT_INTENT_INDEXES[enemyId];
+  return !!s && s.has(intentIndex);
+}
+
+function stableStringify(v: any): string {
+  if (v === null) return "null";
+  const t = typeof v;
+  if (t === "number" || t === "boolean") return String(v);
+  if (t === "string") return JSON.stringify(v);
+  if (Array.isArray(v)) return "[" + v.map(stableStringify).join(",") + "]";
+  if (t === "object") {
+    const keys = Object.keys(v).sort();
+    return "{" + keys.map((k) => JSON.stringify(k) + ":" + stableStringify(v[k])).join(",") + "}";
+  }
+  return JSON.stringify(String(v));
+}
+
+function intentActionKey(intent: any): string {
+  if (!intent) return "NONE";
+  const clone: any = {};
+  for (const k of Object.keys(intent)) {
+    if (k === "label" || k === "text" || k === "desc" || k === "name") continue;
+    clone[k] = intent[k];
+  }
+  if (clone.effects && Array.isArray(clone.effects)) {
+    clone.effects = clone.effects.map((e: any) => {
+      const ec: any = {};
+      for (const kk of Object.keys(e ?? {})) {
+        if (kk === "label" || kk === "text" || kk === "desc" || kk === "name") continue;
+        ec[kk] = e[kk];
+      }
+      return ec;
+    });
+  }
+  return stableStringify(clone);
+}
+
+function commitIntentHistory(e: any, key: string) {
+  const lastKey: string | null = e.lastIntentKey ?? null;
+  const streak: number = e.lastIntentStreak ?? 0;
+  if (lastKey === key) {
+    e.lastIntentStreak = Math.min(3, streak + 1);
+  } else {
+    e.lastIntentKey = key;
+    e.lastIntentStreak = 1;
+  }
+}
+
+function pickNextIntentIndex(intents: any[], lastIndex: number, enemyId: string, lastKey: string | null, streak: number) {
+  const n = intents.length;
+  if (n <= 1) return 0;
+
+  const candidates = Array.from({ length: n }, (_, i) => i);
+
+  const block2 = (ix: number) => ix === lastIndex && shouldBlockRepeatByIndex(enemyId, ix);
+  const block3 = (ix: number) => !!lastKey && streak >= 2 && intentActionKey(intents[ix]) === lastKey;
+
+  const both = candidates.filter((ix) => !block2(ix) && !block3(ix));
+  if (both.length > 0) return pickOne(both);
+
+  const onlyNo3 = candidates.filter((ix) => !block3(ix));
+  if (onlyNo3.length > 0) return pickOne(onlyNo3);
+
+  const onlyNo2 = candidates.filter((ix) => !block2(ix));
+  if (onlyNo2.length > 0) return pickOne(onlyNo2);
+
+  return pickOne(candidates);
+}
+
+function getCombatDeckSize(g: GameState): number {
+  return (
+    g.deck.length +
+    g.hand.length +
+    g.discard.length +
+    g.frontSlots.filter(Boolean).length +
+    g.backSlots.filter(Boolean).length +
+    g.exhausted.length
+  );
+}
+
+function calcDeckSizeDamage(act: { base: number; per: number; div: number; cap?: number }, deckSize: number) {
+  const scale = Math.ceil(deckSize / act.div);
+  let dmg = act.base + act.per * scale;
+  if (act.cap != null) dmg = Math.min(dmg, act.cap);
+  return { dmg, scale };
+}
+
+const SOUL_WARN_INTENT_INDEX = 2;
+const SOUL_NUKE_CHANCE = 0.6;
+
+export function revealIntentsAndDisrupt(g: GameState) {
+  if (g.intentsRevealedThisTurn) return;
+  g.intentsRevealedThisTurn = true;
+
+  g.attackedEnemyIndicesThisTurn = [];
+  g.backUidsThisTurn = [];
+  g.placedUidsThisTurn = [];
+  g.drawCountThisTurn = 0;
+
+  g.phase = "REVEAL";
+
+  g.player.immuneToDisruptThisTurn = false;
+  g.player.nullifyDamageThisTurn = false;
+
+  g.disruptIndexThisTurn = null;
+
+  // Ïä¨Î°Ø Ïàò(Î≥¥Ïä§ Î≥¥ÏÉÅ) Î∞òÏòÅ: backSlots Í∏∏Ïù¥Ïóê ÎßûÏ∂∞ ÍµêÎûÄ Î¨¥Ìö® Ïä¨Î°ØÏùÑ ÏÑ†ÌÉù
+  {
+    const cols = Math.max(1, g.backSlots?.length ?? 3);
+    g.backSlotDisabled = Array.from({ length: cols }, () => false);
+
+    const runAny: any = g.run as any;
+    const backCapRaw = Number(runAny.slotCapBack ?? 3);
+    const backCap = Math.max(3, Math.min(4, Math.floor(backCapRaw)));
+
+    const disrupt = g.player.status.disrupt ?? 0;
+    if (disrupt > 0) {
+      g.disruptIndexThisTurn = Math.floor(Math.random() * backCap);
+      g.backSlotDisabled[g.disruptIndexThisTurn] = true;
+    }
+  }
+
+  for (const e of g.enemies) {
+    e.immuneThisTurn = e.immuneNextTurn;
+    e.immuneNextTurn = false;
+  }
+
+  for (const e of aliveEnemies(g)) {
+    e.intentLabelOverride = undefined;
+
+    const def = g.content.enemiesById[e.id];
+    const intents = def.intents;
+    if (!intents || intents.length === 0) continue;
+
+    const nextIx = pickNextIntentIndex(
+      intents,
+      e.intentIndex ?? 0,
+      e.id,
+      e.lastIntentKey ?? null,
+      e.lastIntentStreak ?? 0
+    );
+
+    e.intentIndex = nextIx;
+
+    const picked = intents[nextIx % intents.length];
+    commitIntentHistory(e, intentActionKey(picked));
+
+    if (e.id === "boss_soul_stealer") {
+      e.soulWillNukeThisTurn = false;
+      const warn = e.soulWarnCount ?? 0;
+      const armed = !!e.soulArmed;
+
+      if (armed) {
+        if (Math.random() < SOUL_NUKE_CHANCE) {
+          e.soulWillNukeThisTurn = true;
+          e.intentLabelOverride = "Ï¢ÖÎßê: 50 ÌîºÌï¥";
+          logMsg(g, `Ï†Å ÏùòÎèÑ: ${e.name} ‚Üí ${e.intentLabelOverride}`);
+          continue;
+        }
+        const it = intents[e.intentIndex % intents.length];
+        e.intentLabelOverride = `${it.label} (Ìè≠Î∞ú Í∞ÄÎä• ÏÉÅÌÉú)`;
+        logMsg(g, `Ï†Å ÏùòÎèÑ: ${e.name} ‚Üí ${e.intentLabelOverride}`);
+        continue;
+      }
+
+      const it = intents[e.intentIndex % intents.length];
+      e.intentLabelOverride = `${it.label} (Í≤ΩÍ≥† ${warn}/3)`;
+      logMsg(g, `Ï†Å ÏùòÎèÑ: ${e.name} ‚Üí ${e.intentLabelOverride}`);
+      continue;
+    }
+
+    const intent = intents[e.intentIndex % intents.length];
+
+    const p = buildIntentPreview(g, e, intent);
+
+    let suffix = "";
+    if (p.dmgTotal != null) {
+      suffix = (p.hits ?? 1) > 1 ? ` (${p.dmgTotal}, ${p.hits}ÌÉÄ)` : ` (${p.dmgTotal})`;
+    } else if ((p.hits ?? 0) > 1) {
+      suffix = ` (${p.hits}ÌÉÄ)`;
+    }
+
+    const label = `${intent.label}${suffix}`;
+
+    e.intentLabelOverride = label;
+    logMsg(g, `Ï†Å ÏùòÎèÑ: ${e.name} ‚Üí ${label}`);
+  }
+
+  if (g.disruptIndexThisTurn !== null) {
+    logMsg(g, `ÍµêÎûÄ: Ïù¥Î≤à ÌÑ¥ ÌõÑÏó¥ ${g.disruptIndexThisTurn} Î¨¥Ìö®`);
+  }
+
+  runRelicHook(g, "onReveal");
+
+  g.phase = "PLACE";
+}
+
+export const __SOUL_WARN_INTENT_INDEX = SOUL_WARN_INTENT_INDEX;
diff -ruN /src/engine/combat/phases.ts /src/engine/combat/phases.ts
--- /src/engine/combat/phases.ts	2026-02-24 10:21:55.000000000 +0000
+++ /src/engine/combat/phases.ts	2026-02-24 11:59:22.425779832 +0000
@@ -19,6 +19,32 @@
   wingArteryBaseSuppliesBonus,
 } from "../faith";
 
+
+// =========================
+// Slot caps (boss rewards)
+// =========================
+function clampSlotCap(v: any): number {
+  const n = Number(v);
+  if (!Number.isFinite(n)) return 3;
+  return Math.max(3, Math.min(4, Math.floor(n)));
+}
+
+function getSlotCap(g: GameState, side: "front" | "back"): number {
+  const runAny: any = g.run as any;
+  return clampSlotCap(side === "front" ? runAny.slotCapFront : runAny.slotCapBack);
+}
+
+function getSlotCols(g: GameState): number {
+  return Math.max(getSlotCap(g, "front"), getSlotCap(g, "back"));
+}
+
+function resetCombatSlots(g: GameState) {
+  const cols = getSlotCols(g);
+  g.frontSlots = Array.from({ length: cols }, () => null);
+  g.backSlots = Array.from({ length: cols }, () => null);
+  g.backSlotDisabled = Array.from({ length: cols }, () => false);
+}
+
 export function startCombat(g: GameState) {
   g.combatTurn = 1;
   g.time = (g.time ?? 0) + 1;
@@ -37,9 +63,7 @@
 
   g.phase = "REVEAL";
 
-  g.frontSlots = [null, null, null];
-  g.backSlots = [null, null, null];
-  g.backSlotDisabled = [false, false, false];
+  resetCombatSlots(g);
 
   g.backUidsThisTurn = [];
 
@@ -173,6 +197,9 @@
   }
 
   const slots = side === "front" ? g.frontSlots : g.backSlots;
+  const cap = getSlotCap(g, side);
+  if (idx < 0 || idx >= cap) return;
+  if (idx >= slots.length) return;
   if (slots[idx]) return;
 
   g.hand = g.hand.filter((x) => x !== cardUid);
@@ -288,7 +315,7 @@
 }
 
 function clearSlots(g: GameState, force = false) {
-  for (let i = 0; i < 3; i++) {
+  for (let i = 0; i < g.frontSlots.length; i++) {
     const f = g.frontSlots[i];
     if (f) {
       if (!force && isInstalledHere(g, f, "front")) {
@@ -318,7 +345,7 @@
 function incrementInstallAges(g: GameState) {
   (g as any).installAgeByUid ??= {};
   // ÏÑ§ÏπòÍ∞Ä Ïú†ÏßÄÎêòÎäî Ïπ¥ÎìúÎßå +1
-  for (let i = 0; i < 3; i++) {
+  for (let i = 0; i < g.frontSlots.length; i++) {
     const f = g.frontSlots[i];
     if (f && isInstalledHere(g, f, "front")) {
       g.installAgeByUid[f] = (g.installAgeByUid[f] ?? 0) + 1;
@@ -335,7 +362,7 @@
   g.phase = "BACK";
   logMsg(g, "=== ÌõÑÏó¥ Îã®Í≥Ñ ===");
 
-  for (let i = 0; i < 3; i++) {
+  for (let i = 0; i < g.backSlots.length; i++) {
     const uid = g.backSlots[i];
     if (!uid) continue;
 
@@ -355,7 +382,7 @@
   if (g.phase !== "FRONT") return;
   logMsg(g, "=== Ï†ÑÏó¥ Îã®Í≥Ñ ===");
 
-  for (let i = 0; i < 3; i++) {
+  for (let i = 0; i < g.frontSlots.length; i++) {
     const uid = g.frontSlots[i];
     if (!uid) continue;
 
@@ -806,7 +833,7 @@
 }
 
 export function _clearSlotsForVictory(g: GameState) {
-  clearSlots(g);
+  clearSlots(g, true);
 }
 
 export function _cleanupBattleTransientForVictory(g: GameState) {
diff -ruN /src/engine/combat/victory.ts /src/engine/combat/victory.ts
--- /src/engine/combat/victory.ts	2026-02-24 04:55:02.000000000 +0000
+++ /src/engine/combat/victory.ts	2026-02-24 11:59:22.428465058 +0000
@@ -3,7 +3,7 @@
 import { resolvePlayerEffects } from "../resolve";
 import { getCardDefFor } from "../../content/cards";
 import { runRelicHook, checkRelicUnlocks, getUnlockProgress, grantRelic } from "../relics";
-import { openBattleCardRewardChoice, openEliteRelicOfferChoice, openBossRelicOfferChoice } from "../engineRewards";
+import { openBattleCardRewardChoice, openEliteRelicOfferChoice, openBossRelicOfferChoice, openBossSlotUpgradeChoice } from "../engineRewards";
 import { _cleanupBattleTransientForVictory } from "./phases";
 import { rollBattleItemDrop } from "../items";
 import { GOD_LINES, getPatronGodOrNull, isHostile } from "../faith";
@@ -190,6 +190,36 @@
       (g.run as any).ominousProphecySeen = false;
       g.player.hp = g.player.maxHp;
       logMsg(g, "Î≥¥Ïä§ Í≤©Ìåå! Ï≤¥Î†•Ïù¥ ÏôÑÏ†ÑÌûà ÌöåÎ≥µÎêòÏóàÏäµÎãàÎã§.");
+
+      // =========================
+      // Î≥¥Ïä§ Î≥¥ÏÉÅ: Ïä¨Î°Ø ÌôïÏû•
+      //  - 1Î≤àÏß∏ Î≥¥Ïä§: Ï†ÑÏó¥/ÌõÑÏó¥ Ï§ë ÌïòÎÇò ÏÑ†ÌÉù(+1)
+      //  - 2Î≤àÏß∏ Î≥¥Ïä§: ÎÇòÎ®∏ÏßÄ ÏûêÎèô(+1)
+      // =========================
+      {
+        const runAny: any = g.run as any;
+        runAny.slotCapFront = Math.max(3, Math.min(4, Math.floor(Number(runAny.slotCapFront ?? 3))));
+        runAny.slotCapBack  = Math.max(3, Math.min(4, Math.floor(Number(runAny.slotCapBack  ?? 3))));
+
+        runAny.bossKillCount = (Number(runAny.bossKillCount ?? 0) || 0) + 1;
+        const k = Number(runAny.bossKillCount) || 0;
+
+        if (k === 1) {
+          openBossSlotUpgradeChoice(g);
+        } else if (k === 2) {
+          const first = String(runAny.bossSlotFirstPick ?? "");
+          if (first === "front") {
+            if (runAny.slotCapBack < 4) runAny.slotCapBack += 1;
+            pushUiToast(g, "INFO", "Î≥¥Ïä§ Î≥¥ÏÉÅ: ÌõÑÏó¥ Ïä¨Î°Ø +1", 2000);
+            logMsg(g, "Î≥¥Ïä§ Î≥¥ÏÉÅ: ÌõÑÏó¥ Ïä¨Î°Ø +1");
+          } else {
+            if (runAny.slotCapFront < 4) runAny.slotCapFront += 1;
+            pushUiToast(g, "INFO", "Î≥¥Ïä§ Î≥¥ÏÉÅ: Ï†ÑÏó¥ Ïä¨Î°Ø +1", 2000);
+            logMsg(g, "Î≥¥Ïä§ Î≥¥ÏÉÅ: Ï†ÑÏó¥ Ïä¨Î°Ø +1");
+          }
+        }
+      }
+
       openBossRelicOfferChoice(g); // 3Í∞ú Ï§ë 1Í∞ú
     }
 
diff -ruN /src/engine/engineRewards.ts /src/engine/engineRewards.ts
--- /src/engine/engineRewards.ts	2026-02-23 14:36:44.000000000 +0000
+++ /src/engine/engineRewards.ts	2026-02-24 11:59:22.428974486 +0000
@@ -1,527 +1,594 @@
-import type { ChoiceOption, ChoiceState, GameState, ShopState, ShopCardOffer } from "./types";
-import { addCardToDeck, offerRewardN, removeCardByUid, REWARD_POOL } from "../content/rewards";
-import { closeChoice, enqueueChoice } from "./choice";
-import { logMsg, pushUiToast } from "./rules";
-import { getCardDefByIdWithUpgrade } from "../content/cards";
-import { offerRelicSingleContent } from "../content/relicRewards";
-import { ITEMS, getItemDefById } from "../content/items";
-import { RELICS_BY_ID } from "../content/relicsContent";
-import { grantRelic } from "./relics";
-import { addItemToInventory } from "./items";
-import { GOD_LINES, faithCardRewardCount, getPatronGodOrNull, isHostile, shopPriceGold } from "./faith";
-
-export function openBattleCardRewardChoice(g: GameState, opts?: { itemOfferId?: string; itemSource?: string }) {
-  const ctx: any = (g.run as any).lastBattleWasBoss ? "BOSS" : g.run.lastBattleWasElite ? "ELITE" : "BATTLE";
-  const n = faithCardRewardCount(g);
-  const offers = offerRewardN(g, ctx, n);
-  if (!offers || offers.length === 0) return;
-
-  // Ï≤´ Î≤àÏß∏ Ïù∏Í∞Ñ: Î≥¥ÏÉÅ ÌôîÎ©¥ ÌÜ†Ïä§Ìä∏
-  if (getPatronGodOrNull(g) === "first_human") {
-    pushUiToast(g, "INFO", GOD_LINES.first_human.reward, 1800);
-    logMsg(g, GOD_LINES.first_human.reward);
-  } else if (isHostile(g, "first_human")) {
-    pushUiToast(g, "WARN", GOD_LINES.first_human.hostileReward, 1800);
-    logMsg(g, GOD_LINES.first_human.hostileReward);
-  }
-
-  const options: ChoiceOption[] = offers.map((o) => {
-    const def = getCardDefByIdWithUpgrade(g.content, o.defId, o.upgrade);
-    const label = `${def.name}${o.upgrade > 0 ? ` +${o.upgrade}` : ""}`;
-    return {
-      key: `pick:${o.defId}:${o.upgrade}`,
-      label,
-      detail: `Ï†ÑÏó¥: ${def.frontText} / ÌõÑÏó¥: ${def.backText}`,
-    };
-  });
-  options.push({ key: "skip", label: "ÏÉùÎûµ", detail: "" });
-
-  const choice: ChoiceState = {
-    kind: "REWARD",
-    title: "Ï†ÑÌà¨ Î≥¥ÏÉÅ",
-    prompt: "Ïπ¥Îìú 1Ïû•ÏùÑ ÏÑ†ÌÉùÌïòÍ±∞ÎÇò ÏÉùÎûµÌï©ÎãàÎã§.",
-    options,
-  };
-
-  const itemOfferId = opts?.itemOfferId;
-  const itemSource = opts?.itemSource ?? "BATTLE";
-
-  enqueueChoice(g, choice, {
-    kind: "BATTLE_REWARD",
-    offers: offers as any,
-    itemOfferId,
-    itemSource,
-    cardDecision: undefined,
-    itemDecision: undefined,
-  } as any);
-}
-
-export function openEliteRelicOfferChoice(g: GameState) {
-  if (!g.run.lastBattleWasElite) return;
-  if (g.run.eliteRelicOfferedThisBattle) return;
-
-  const roll = offerRelicSingleContent(g, 1);
-  if (!roll) return;
-
-  g.run.eliteRelicOfferedThisBattle = true;
-
-  const r = roll.choices[0];
-  if (!r) return;
-  const rid = r.id;
-  const def: any = RELICS_BY_ID[rid];
-
-  const isLocked = !!def?.unlock;
-
-  const displayName = isLocked
-    ? (def?.dormantName ?? def?.name ?? rid)
-    : (def?.name ?? rid);
-
-  const displayDesc = isLocked
-    ? [def?.dormantText, def?.unlockHint].filter(Boolean).join("\n \n")
-    : (def?.text ?? "");
-
-  const options = [
-    { key: "take", label: "Î∞õÍ∏∞", detail: `${displayName}\n\n${displayDesc}` },
-    { key: "skip", label: "ÏÉùÎûµ", detail: "" },
-  ];
-
-
-  const choice: ChoiceState = {
-    kind: "REWARD", 
-    title: "Ï†ïÏòà Î≥¥ÏÉÅ: Ïú†Î¨º",
-    prompt: "Ïú†Î¨ºÏùÑ Î∞õÍ±∞ÎÇò ÏÉùÎûµÌï©ÎãàÎã§.",
-    options,
-  };
-
-  (choice as any).art = def?.art ?? undefined;
-
-
-  enqueueChoice(g, choice, { kind: "ELITE_RELIC", offerIds: [rid] });
-}
-
-export function openBattleItemRewardChoice(g: GameState, itemId: string, source: string = "BATTLE") {
-  const def = getItemDefById(itemId);
-  if (!def) return;
-
-  const choice: ChoiceState = {
-    kind: "REWARD",
-    title: "Ï†ÑÌà¨ Î≥¥ÏÉÅ: ÏïÑÏù¥ÌÖú",
-    prompt: "ÏïÑÏù¥ÌÖúÏùÑ Î∞õÍ±∞ÎÇò ÏÉùÎûµÌï©ÎãàÎã§.",
-    options: [
-      { key: "take", label: "Î∞õÍ∏∞", detail: `${def.name}\n\n${def.text}` },
-      { key: "skip", label: "ÏÉùÎûµ", detail: "" },
-    ],
-  };
-
-  (choice as any).art = def.art;
-  enqueueChoice(g, choice, { kind: "ITEM_REWARD", offerId: itemId, source } as any);
-}
-
-
-export function applyRewardChoiceKey(g: GameState, key: string): boolean {
-  const choice = g.choice;
-  if (!choice) return false;
-
-  // Combined battle reward: allow taking/skipping item without closing the choice.
-  {
-    const ctx: any = g.choiceCtx as any;
-    if (ctx?.kind === "BATTLE_REWARD" || ctx?.kind === "BATTLE_CARD_REWARD") {
-      const offerId = String(ctx.itemOfferId ?? "");
-      if (key === "take_item") {
-        if (!offerId) return true;
-        if (ctx.itemDecision) return true;
-        const ok = addItemToInventory(g, offerId, String(ctx.itemSource ?? "BATTLE"));
-        if (!ok) return true;
-        ctx.itemDecision = "TAKEN";
-        if (ctx.cardDecision) closeChoice(g);
-        return true;
-      }
-      if (key === "skip_item") {
-        if (!offerId) return true;
-        if (ctx.itemDecision) return true;
-        logMsg(g, "ÏïÑÏù¥ÌÖú Î≥¥ÏÉÅÏùÑ ÏÉùÎûµÌñàÏäµÎãàÎã§.");
-        ctx.itemDecision = "SKIPPED";
-        if (ctx.cardDecision) closeChoice(g);
-        return true;
-      }
-    }
-  }
-
-  if (key === "take") {
-    const ctx: any = g.choiceCtx as any;
-
-    if (ctx?.kind === "ELITE_RELIC") {
-      const id = ctx.offerIds?.[0];
-      if (!id) return false;
-
-      g.run.relics ??= [];
-      if (!g.run.relics.includes(id)) grantRelic(g, id);
-
-      logMsg(g, `Ïú†Î¨º ÌöçÎìù: ${RELICS_BY_ID[id]?.name ?? id}`);
-      closeChoice(g);
-      return true;
-    }
-
-    if (ctx?.kind === "ITEM_REWARD") {
-      const id = String(ctx.offerId ?? "");
-      if (!id) return false;
-
-      const ok = addItemToInventory(g, id, String(ctx.source ?? "BATTLE"));
-      if (!ok) return true;
-
-      closeChoice(g);
-      return true;
-    }
-
-    return false;
-  }
-
-  if (key === "skip") {
-    const ctx: any = g.choiceCtx as any;
-    const isBattleReward = ctx?.kind === "BATTLE_REWARD" || ctx?.kind === "BATTLE_CARD_REWARD";
-    const itemId = String(ctx?.itemOfferId ?? "");
-
-    if (isBattleReward && itemId) {
-      if (ctx.cardDecision) return true;
-      logMsg(g, "Ïπ¥Îìú Î≥¥ÏÉÅÏùÑ ÏÉùÎûµÌñàÏäµÎãàÎã§.");
-      ctx.cardDecision = "SKIPPED";
-      if (ctx.itemDecision) closeChoice(g);
-      return true;
-    }
-
-    logMsg(g, "Î≥¥ÏÉÅÏùÑ ÏÉùÎûµÌñàÏäµÎãàÎã§.");
-    closeChoice(g);
-    return true;
-  }
-
-  if (key.startsWith("pick:")) {
-    const parts = key.split(":");
-    const defId = parts[1] ?? "";
-    const upgrade = Number(parts[2] ?? 0);
-
-    if (!defId) return false;
-
-    const ctx: any = g.choiceCtx as any;
-    const isBattleReward = ctx?.kind === "BATTLE_REWARD" || ctx?.kind === "BATTLE_CARD_REWARD";
-    const itemId = String(ctx?.itemOfferId ?? "");
-
-    // ÏïÑÏù¥ÌÖú Î≥¥ÏÉÅÏù¥ Í∞ôÏù¥ Í±∏Î†§ÏûàÏúºÎ©¥, Ïπ¥ÎìúÎ∂ÄÌÑ∞ ÏßëÏñ¥ÎèÑ ÌôîÎ©¥ÏùÑ Îã´ÏßÄ ÏïäÍ≤å
-    if (isBattleReward && itemId) {
-      if (ctx.cardDecision) return true;
-      addCardToDeck(g, defId, { upgrade: Number.isFinite(upgrade) ? upgrade : 0 });
-      logMsg(g, "Ïπ¥Îìú ÌöçÎìù: " + defId + (upgrade > 0 ? " +" + upgrade : ""));
-      ctx.cardDecision = key;
-      if (ctx.itemDecision) closeChoice(g);
-      return true;
-    }
-
-    addCardToDeck(g, defId, { upgrade: Number.isFinite(upgrade) ? upgrade : 0 });
-    logMsg(g, "Ïπ¥Îìú ÌöçÎìù: " + defId + (upgrade > 0 ? " +" + upgrade : ""));
-    closeChoice(g);
-    return true;
-  }
-
-  if (key.startsWith("up:")) {
-    const uid = key.slice("up:".length);
-    if (!uid) return false;
-
-    const card = g.cards[uid];
-    if (!card) return false;
-
-    const base = g.content.cardsById[card.defId];
-    const ups = base?.upgrades ?? [];
-    const curU = card.upgrade ?? 0;
-
-    if (curU >= ups.length) {
-      logMsg(g, "Ïù¥ÎØ∏ ÏµúÎåÄ Í∞ïÌôîÏûÖÎãàÎã§.");
-      closeChoice(g);
-      return true;
-    }
-
-    card.upgrade = curU + 1;
-    const defNow = getCardDefByIdWithUpgrade(g.content, card.defId, card.upgrade);
-    logMsg(g, `Ïπ¥Îìú Í∞ïÌôî: ${defNow.name} +${card.upgrade}`);
-    closeChoice(g);
-    return true;
-  }
-
-  if (key.startsWith("remove:")) {
-    const uid = key.slice("remove:".length);
-    if (!uid) return false;
-
-    const ok = removeCardByUid(g, uid);
-    if (!ok) return false;
-
-    closeChoice(g);
-    return true;
-  }
-
-  if (key.startsWith("relic:")) {
-    const id = key.slice("relic:".length);
-    if (!id) return false;
-
-    const offerIds = (g.choiceCtx as any)?.offerIds as string[] | undefined;
-    if (offerIds && offerIds.length > 0 && !offerIds.includes(id)) return false;
-
-    g.run.relics ??= [];
-    if (!g.run.relics.includes(id)) grantRelic(g, id);
-
-    logMsg(g, `Ïú†Î¨º ÌöçÎìù: ${RELICS_BY_ID[id]?.name ?? id}`);
-    closeChoice(g);
-    return true;
-  }
-
-  return false;
-}
-
-export function openRelicOfferChoice(
-  g: GameState,
-  opt: {
-    count: number;
-    title: string;
-    prompt: string;
-    allowSkip?: boolean;
-    source?: "BOSS" | "ELITE" | "PAID" | string;
-    artKeyOrPath?: string;
-  }
-) {
-  const roll = offerRelicSingleContent(g, opt.count);
-  if (!roll || roll.choices.length === 0) return null;
-
-  const offerIds = roll.choices.map((x) => x.id);
-
-  const options = roll.choices.map((r) => {
-    const def: any = RELICS_BY_ID[r.id];
-    const isLocked = !!def?.unlock;
-
-    const displayName = isLocked
-      ? (def?.dormantName ?? def?.name ?? r.id)
-      : (def?.name ?? r.id);
-
-    const displayDesc = isLocked
-      ? [def?.dormantText, def?.unlockHint].filter(Boolean).join("\n \n")
-      : (def?.text ?? "");
-
-    return {
-      key: `relic:${r.id}`,
-      label: displayName,
-      detail: `${displayName}\n\n${displayDesc}`,
-    };
-  });
-
-  if (opt.allowSkip) options.push({ key: "skip", label: "ÏÉùÎûµ", detail: "" });
-
-  const choice: ChoiceState = {
-    kind: "REWARD",
-    title: opt.title,
-    prompt: opt.prompt,
-    options,
-  };
-
-  // ÏÑ†ÌÉù ÌôîÎ©¥ ÏùºÎü¨Ïä§Ìä∏ (Ïòà: Î≥¥Ïä§ Ïú†Î¨º ÏÑ†ÌÉù)
-  if (opt.artKeyOrPath) {
-    const k = String(opt.artKeyOrPath);
-    const art = (k.includes("/") || k.includes("\\") || k.includes(".")) ? k : `assets/ui/${k}.png`;
-    (choice as any).art = art;
-  }
-
-  enqueueChoice(g, choice, { kind: "RELIC_OFFER", offerIds, source: opt.source });
-  return offerIds;
-}
-
-export function openBossRelicOfferChoice(g: GameState) {
-  return openRelicOfferChoice(g, {
-    count: 3,
-    title: "Î≥¥Ïä§ Î≥¥ÏÉÅ: Ïú†Î¨º",
-    prompt: "Ïú†Î¨º 1Í∞úÎ•º ÏÑ†ÌÉùÌï©ÎãàÎã§.",
-    allowSkip: false,
-    source: "BOSS",
-    artKeyOrPath: "what_to_do",
-  });
-}
-
-// =========================
-// Shop
-// =========================
-
-const randInt = (min: number, max: number) => min + Math.floor(Math.random() * (max - min + 1));
-
-const cardBasePrice = (rarity: string) => {
-  switch (rarity) {
-    case "SPECIAL": return 20;
-    case "RARE": return 30;
-    case "COMMON":
-    default: return 10;
-  }
-};
-
-function ensureShopState(g: GameState, nodeId: string): ShopState {
-  const runAny = g.run as any;
-  runAny.shops ??= {};
-  const existing = runAny.shops[nodeId] as ShopState | undefined;
-  if (existing) return existing;
-
-    // ÏÉÅÏ†ê Ïπ¥Îìú ÌíÄ: REWARD_POOLÏóêÏÑú weight>0Ïù∏ Ïπ¥ÎìúÎßå (Ï†ÄÏ£º/ÎØ∏ÏÇ¨Ïö© Ïπ¥Îìú Î∞©ÏßÄ)
-  const weightedIds = REWARD_POOL.filter((e) => (e.weight ?? 0) > 0).map((e) => e.id);
-
-  const allCardIds = (weightedIds.length > 0 ? weightedIds : Object.keys(g.content.cardsById))
-    .filter((id) => {
-      const base = g.content.cardsById[id];
-      const r = (base?.rarity ?? "COMMON");
-      return r !== "BASIC" && r !== "MADNESS";
-    });
-  const picks: string[] = [];
-
-  const want = 6;
-  let tries = 0;
-  while (picks.length < want && tries++ < 200) {
-    const id = allCardIds[Math.floor(Math.random() * allCardIds.length)];
-    if (!id) continue;
-    if (picks.includes(id) && Math.random() < 0.8) continue;
-    picks.push(id);
-  }
-
-  const cards: ShopCardOffer[] = picks.map((defId) => {
-    const base = g.content.cardsById[defId];
-    const r = (base?.rarity ?? "COMMON");
-    const price = Math.max(1, cardBasePrice(r) + randInt(-2, 2));
-    return { defId, upgrade: 0, priceGold: price, sold: false };
-  });
-
-  const items = (() => {
-    const ids = ITEMS.map((x) => x.id);
-    const wantI = 2;
-    const picksI: string[] = [];
-    let triesI = 0;
-    while (picksI.length < wantI && triesI++ < 80 && ids.length > 0) {
-      const id = ids[Math.floor(Math.random() * ids.length)];
-      if (!id) continue;
-      if (picksI.includes(id) && Math.random() < 0.85) continue;
-      picksI.push(id);
-    }
-
-    return picksI.map((itemId) => {
-      const def = getItemDefById(itemId);
-      const base = Number(def?.priceGold ?? 18) || 18;
-      const price = Math.max(1, base + randInt(-2, 2));
-      return { itemId, priceGold: price, sold: false };
-    });
-  })();
-
-  const st: ShopState = {
-    nodeId,
-    cards,
-    items,
-    usedUpgrade: false,
-    usedRemove: false,
-    createdAtMove: Number((g.run as any).timeMove ?? 0) || 0,
-    art: "assets/ui/background/shop_bg.png",
-  };
-
-  runAny.shops[nodeId] = st;
-  return st;
-}
-
-export function openShopChoice(g: GameState, nodeId: string) {
-  const shop = ensureShopState(g, nodeId);
-
-  // shop visit toasts (1Ìöå)
-  if (getPatronGodOrNull(g) === "first_human" && !(shop as any)._firstHumanShopToastShown) {
-    (shop as any)._firstHumanShopToastShown = true;
-    pushUiToast(g, "WARN", GOD_LINES.first_human.shop, 2200);
-    logMsg(g, GOD_LINES.first_human.shop);
-  }
-  if (isHostile(g, "card_dealer") && !(shop as any)._cardDealerHostileShopToastShown) {
-    (shop as any)._cardDealerHostileShopToastShown = true;
-    pushUiToast(g, "WARN", GOD_LINES.card_dealer.hostileShop, 2200);
-    logMsg(g, GOD_LINES.card_dealer.hostileShop);
-  }
-
-  const options: ChoiceOption[] = [];
-  let sep = 0;
-
-  // Ïπ¥Îìú ÌåêÎß§
-  for (let i = 0; i < shop.cards.length; i++) {
-    const o = shop.cards[i];
-    const base = g.content.cardsById[o.defId];
-    const name = base?.name ?? o.defId;
-    const upTxt = (o.upgrade ?? 0) > 0 ? ` +${o.upgrade}` : "";
-
-    if (o.sold) {
-      options.push({ key: `shop:card:${i}`, label: `${name}${upTxt} (ÌíàÏ†à)`, detail: "" });
-      continue;
-    }
-
-    const priceGold = shopPriceGold(g, o.priceGold);
-    const def = getCardDefByIdWithUpgrade(g.content, o.defId, o.upgrade ?? 0);
-    const detail = `Í∞ÄÍ≤©: ü™ô${priceGold}
-
-Ï†ÑÏó¥: ${def.frontText}
-ÌõÑÏó¥: ${def.backText}`;
-    options.push({ key: `shop:card:${i}`, label: `${name}${upTxt} (ü™ô${priceGold})`, detail });
-  }
-
-  options.push({ key: `shop:sep:${sep++}`, label: "‚Äî", detail: "" });
-
-  // ÏïÑÏù¥ÌÖú ÌåêÎß§
-  if (shop.items && shop.items.length > 0) {
-    for (let i = 0; i < shop.items.length; i++) {
-      const it = shop.items[i];
-      const def = getItemDefById(it.itemId);
-      const name = def?.name ?? it.itemId;
-
-      if (it.sold) {
-        options.push({ key: `shop:item:${i}`, label: `${name} (ÌíàÏ†à)`, detail: "" });
-        continue;
-      }
-
-      const priceGold = shopPriceGold(g, it.priceGold);
-      const detail = `Í∞ÄÍ≤©: ü™ô${priceGold}\n\n${def?.text ?? ""}`;
-      options.push({ key: `shop:item:${i}`, label: `${name} (ü™ô${priceGold})`, detail });
-    }
-
-    options.push({ key: `shop:sep:${sep++}`, label: "‚Äî", detail: "" });
-  }
-
-  // ÏÑúÎπÑÏä§/Î≥¥Í∏â
-  const upLabel = shop.usedUpgrade ? "Ïπ¥Îìú Í∞ïÌôî (ÏÇ¨Ïö© ÏôÑÎ£å)" : "Ïπ¥Îìú Í∞ïÌôî";
-  const rmLabel = shop.usedRemove ? "Ïπ¥Îìú Ï†úÍ±∞ (ÏÇ¨Ïö© ÏôÑÎ£å)" : "Ïπ¥Îìú Ï†úÍ±∞";
-
-  const upPrice = shopPriceGold(g, 25);
-  const rmPrice = shopPriceGold(g, 25);
-  const buySPrice = shopPriceGold(g, 6);
-
-  options.push({ key: "shop:service:upgrade", label: upLabel, detail: shop.usedUpgrade ? "" : `Í∞ÄÍ≤©: ü™ô${upPrice} Ïπ¥Îìú 1Ïû•ÏùÑ Í∞ïÌôîÌï©ÎãàÎã§.` });
-  options.push({ key: "shop:service:remove", label: rmLabel, detail: shop.usedRemove ? "" : `Í∞ÄÍ≤©: ü™ô${rmPrice} Îç±ÏóêÏÑú Ïπ¥Îìú 1Ïû•ÏùÑ Ï†úÍ±∞Ìï©ÎãàÎã§.` });
-  options.push({ key: "shop:supply:buy", label: "Î≥¥Í∏â Íµ¨Îß§", detail: `-ü™ô${buySPrice}, Îã§Ïùå Ï†ÑÌà¨ Î≥¥Í∏â üçû +3` });
-  options.push({ key: "shop:supply:sell", label: "Î≥¥Í∏â ÌåêÎß§", detail: "Îã§Ïùå Ï†ÑÌà¨ Î≥¥Í∏â üçû -3, +ü™ô4" });
-
-  options.push({ key: "shop:leave", label: "ÎÇòÍ∞ÄÍ∏∞", detail: "" });
-
-  {
-    const seen = new Set<string>();
-    const dups: string[] = [];
-    for (const o of options) {
-      if (seen.has(o.key)) dups.push(o.key);
-      seen.add(o.key);
-    }
-    if (dups.length) {
-      logMsg(g, `Í≤ΩÍ≥†: ÏÉÅÏ†ê ÏÑ†ÌÉùÌÇ§ Ï§ëÎ≥µ: ${dups.join(", ")}`);
-    }
-  }
-
-  const choice: ChoiceState = {
-    kind: "EVENT",
-    title: "Í≥†Î∏îÎ¶∞Ïùò ÏÉÅÏ†ê",
-    prompt: "Ïò®Í±¥Ìåå Í≥†Î∏îÎ¶∞Ïùò ÏÉÅÏ†êÏûÖÎãàÎã§.",
-    options,
-  };
-
-  if (shop.art) (choice as any).art = shop.art;
-
-  g.choiceQueue = [];
-  g.choiceStack = [];
-  g.choice = choice;
-  g.choiceCtx = { kind: "SHOP", nodeId } as any;
-  if (shop.art) (choice as any).art = shop.art;
-}
+import type { ChoiceOption, ChoiceState, GameState, ShopState, ShopCardOffer } from "./types";
+import { addCardToDeck, offerRewardN, removeCardByUid, REWARD_POOL } from "../content/rewards";
+import { closeChoice, enqueueChoice } from "./choice";
+import { logMsg, pushUiToast } from "./rules";
+import { getCardDefByIdWithUpgrade } from "../content/cards";
+import { offerRelicSingleContent } from "../content/relicRewards";
+import { ITEMS, getItemDefById } from "../content/items";
+import { RELICS_BY_ID } from "../content/relicsContent";
+import { grantRelic } from "./relics";
+import { addItemToInventory } from "./items";
+import { GOD_LINES, faithCardRewardCount, getPatronGodOrNull, isHostile, shopPriceGold } from "./faith";
+
+export function openBattleCardRewardChoice(g: GameState, opts?: { itemOfferId?: string; itemSource?: string }) {
+  const ctx: any = (g.run as any).lastBattleWasBoss ? "BOSS" : g.run.lastBattleWasElite ? "ELITE" : "BATTLE";
+  const n = faithCardRewardCount(g);
+  const offers = offerRewardN(g, ctx, n);
+  if (!offers || offers.length === 0) return;
+
+  // Ï≤´ Î≤àÏß∏ Ïù∏Í∞Ñ: Î≥¥ÏÉÅ ÌôîÎ©¥ ÌÜ†Ïä§Ìä∏
+  if (getPatronGodOrNull(g) === "first_human") {
+    pushUiToast(g, "INFO", GOD_LINES.first_human.reward, 1800);
+    logMsg(g, GOD_LINES.first_human.reward);
+  } else if (isHostile(g, "first_human")) {
+    pushUiToast(g, "WARN", GOD_LINES.first_human.hostileReward, 1800);
+    logMsg(g, GOD_LINES.first_human.hostileReward);
+  }
+
+  const options: ChoiceOption[] = offers.map((o) => {
+    const def = getCardDefByIdWithUpgrade(g.content, o.defId, o.upgrade);
+    const label = `${def.name}${o.upgrade > 0 ? ` +${o.upgrade}` : ""}`;
+    return {
+      key: `pick:${o.defId}:${o.upgrade}`,
+      label,
+      detail: `Ï†ÑÏó¥: ${def.frontText} / ÌõÑÏó¥: ${def.backText}`,
+    };
+  });
+  options.push({ key: "skip", label: "ÏÉùÎûµ", detail: "" });
+
+  const choice: ChoiceState = {
+    kind: "REWARD",
+    title: "Ï†ÑÌà¨ Î≥¥ÏÉÅ",
+    prompt: "Ïπ¥Îìú 1Ïû•ÏùÑ ÏÑ†ÌÉùÌïòÍ±∞ÎÇò ÏÉùÎûµÌï©ÎãàÎã§.",
+    options,
+  };
+
+  const itemOfferId = opts?.itemOfferId;
+  const itemSource = opts?.itemSource ?? "BATTLE";
+
+  enqueueChoice(g, choice, {
+    kind: "BATTLE_REWARD",
+    offers: offers as any,
+    itemOfferId,
+    itemSource,
+    cardDecision: undefined,
+    itemDecision: undefined,
+  } as any);
+}
+
+export function openEliteRelicOfferChoice(g: GameState) {
+  if (!g.run.lastBattleWasElite) return;
+  if (g.run.eliteRelicOfferedThisBattle) return;
+
+  const roll = offerRelicSingleContent(g, 1);
+  if (!roll) return;
+
+  g.run.eliteRelicOfferedThisBattle = true;
+
+  const r = roll.choices[0];
+  if (!r) return;
+  const rid = r.id;
+  const def: any = RELICS_BY_ID[rid];
+
+  const isLocked = !!def?.unlock;
+
+  const displayName = isLocked
+    ? (def?.dormantName ?? def?.name ?? rid)
+    : (def?.name ?? rid);
+
+  const displayDesc = isLocked
+    ? [def?.dormantText, def?.unlockHint].filter(Boolean).join("\n \n")
+    : (def?.text ?? "");
+
+  const options = [
+    { key: "take", label: "Î∞õÍ∏∞", detail: `${displayName}\n\n${displayDesc}` },
+    { key: "skip", label: "ÏÉùÎûµ", detail: "" },
+  ];
+
+
+  const choice: ChoiceState = {
+    kind: "REWARD", 
+    title: "Ï†ïÏòà Î≥¥ÏÉÅ: Ïú†Î¨º",
+    prompt: "Ïú†Î¨ºÏùÑ Î∞õÍ±∞ÎÇò ÏÉùÎûµÌï©ÎãàÎã§.",
+    options,
+  };
+
+  (choice as any).art = def?.art ?? undefined;
+
+
+  enqueueChoice(g, choice, { kind: "ELITE_RELIC", offerIds: [rid] });
+}
+
+export function openBattleItemRewardChoice(g: GameState, itemId: string, source: string = "BATTLE") {
+  const def = getItemDefById(itemId);
+  if (!def) return;
+
+  const choice: ChoiceState = {
+    kind: "REWARD",
+    title: "Ï†ÑÌà¨ Î≥¥ÏÉÅ: ÏïÑÏù¥ÌÖú",
+    prompt: "ÏïÑÏù¥ÌÖúÏùÑ Î∞õÍ±∞ÎÇò ÏÉùÎûµÌï©ÎãàÎã§.",
+    options: [
+      { key: "take", label: "Î∞õÍ∏∞", detail: `${def.name}\n\n${def.text}` },
+      { key: "skip", label: "ÏÉùÎûµ", detail: "" },
+    ],
+  };
+
+  (choice as any).art = def.art;
+  enqueueChoice(g, choice, { kind: "ITEM_REWARD", offerId: itemId, source } as any);
+}
+
+
+export function applyRewardChoiceKey(g: GameState, key: string): boolean {
+  const choice = g.choice;
+  if (!choice) return false;
+
+  // Combined battle reward: allow taking/skipping item without closing the choice.
+  {
+    const ctx: any = g.choiceCtx as any;
+    if (ctx?.kind === "BATTLE_REWARD" || ctx?.kind === "BATTLE_CARD_REWARD") {
+      const offerId = String(ctx.itemOfferId ?? "");
+      if (key === "take_item") {
+        if (!offerId) return true;
+        if (ctx.itemDecision) return true;
+        const ok = addItemToInventory(g, offerId, String(ctx.itemSource ?? "BATTLE"));
+        if (!ok) return true;
+        ctx.itemDecision = "TAKEN";
+        if (ctx.cardDecision) closeChoice(g);
+        return true;
+      }
+      if (key === "skip_item") {
+        if (!offerId) return true;
+        if (ctx.itemDecision) return true;
+        logMsg(g, "ÏïÑÏù¥ÌÖú Î≥¥ÏÉÅÏùÑ ÏÉùÎûµÌñàÏäµÎãàÎã§.");
+        ctx.itemDecision = "SKIPPED";
+        if (ctx.cardDecision) closeChoice(g);
+        return true;
+      }
+    }
+  }
+
+  if (key === "take") {
+    const ctx: any = g.choiceCtx as any;
+
+    if (ctx?.kind === "ELITE_RELIC") {
+      const id = ctx.offerIds?.[0];
+      if (!id) return false;
+
+      g.run.relics ??= [];
+      if (!g.run.relics.includes(id)) grantRelic(g, id);
+
+      logMsg(g, `Ïú†Î¨º ÌöçÎìù: ${RELICS_BY_ID[id]?.name ?? id}`);
+      closeChoice(g);
+      return true;
+    }
+
+    if (ctx?.kind === "ITEM_REWARD") {
+      const id = String(ctx.offerId ?? "");
+      if (!id) return false;
+
+      const ok = addItemToInventory(g, id, String(ctx.source ?? "BATTLE"));
+      if (!ok) return true;
+
+      closeChoice(g);
+      return true;
+    }
+
+    return false;
+  }
+
+  if (key === "skip") {
+    const ctx: any = g.choiceCtx as any;
+    const isBattleReward = ctx?.kind === "BATTLE_REWARD" || ctx?.kind === "BATTLE_CARD_REWARD";
+    const itemId = String(ctx?.itemOfferId ?? "");
+
+    if (isBattleReward && itemId) {
+      if (ctx.cardDecision) return true;
+      logMsg(g, "Ïπ¥Îìú Î≥¥ÏÉÅÏùÑ ÏÉùÎûµÌñàÏäµÎãàÎã§.");
+      ctx.cardDecision = "SKIPPED";
+      if (ctx.itemDecision) closeChoice(g);
+      return true;
+    }
+
+    logMsg(g, "Î≥¥ÏÉÅÏùÑ ÏÉùÎûµÌñàÏäµÎãàÎã§.");
+    closeChoice(g);
+    return true;
+  }
+
+  if (key.startsWith("pick:")) {
+    const parts = key.split(":");
+    const defId = parts[1] ?? "";
+    const upgrade = Number(parts[2] ?? 0);
+
+    if (!defId) return false;
+
+    const ctx: any = g.choiceCtx as any;
+    const isBattleReward = ctx?.kind === "BATTLE_REWARD" || ctx?.kind === "BATTLE_CARD_REWARD";
+    const itemId = String(ctx?.itemOfferId ?? "");
+
+    // ÏïÑÏù¥ÌÖú Î≥¥ÏÉÅÏù¥ Í∞ôÏù¥ Í±∏Î†§ÏûàÏúºÎ©¥, Ïπ¥ÎìúÎ∂ÄÌÑ∞ ÏßëÏñ¥ÎèÑ ÌôîÎ©¥ÏùÑ Îã´ÏßÄ ÏïäÍ≤å
+    if (isBattleReward && itemId) {
+      if (ctx.cardDecision) return true;
+      addCardToDeck(g, defId, { upgrade: Number.isFinite(upgrade) ? upgrade : 0 });
+      logMsg(g, "Ïπ¥Îìú ÌöçÎìù: " + defId + (upgrade > 0 ? " +" + upgrade : ""));
+      ctx.cardDecision = key;
+      if (ctx.itemDecision) closeChoice(g);
+      return true;
+    }
+
+    addCardToDeck(g, defId, { upgrade: Number.isFinite(upgrade) ? upgrade : 0 });
+    logMsg(g, "Ïπ¥Îìú ÌöçÎìù: " + defId + (upgrade > 0 ? " +" + upgrade : ""));
+    closeChoice(g);
+    return true;
+  }
+
+  if (key.startsWith("up:")) {
+    const uid = key.slice("up:".length);
+    if (!uid) return false;
+
+    const card = g.cards[uid];
+    if (!card) return false;
+
+    const base = g.content.cardsById[card.defId];
+    const ups = base?.upgrades ?? [];
+    const curU = card.upgrade ?? 0;
+
+    if (curU >= ups.length) {
+      logMsg(g, "Ïù¥ÎØ∏ ÏµúÎåÄ Í∞ïÌôîÏûÖÎãàÎã§.");
+      closeChoice(g);
+      return true;
+    }
+
+    card.upgrade = curU + 1;
+    const defNow = getCardDefByIdWithUpgrade(g.content, card.defId, card.upgrade);
+    logMsg(g, `Ïπ¥Îìú Í∞ïÌôî: ${defNow.name} +${card.upgrade}`);
+    closeChoice(g);
+    return true;
+  }
+
+  if (key.startsWith("remove:")) {
+    const uid = key.slice("remove:".length);
+    if (!uid) return false;
+
+    const ok = removeCardByUid(g, uid);
+    if (!ok) return false;
+
+    closeChoice(g);
+    return true;
+  }
+
+  if (key.startsWith("relic:")) {
+    const id = key.slice("relic:".length);
+    if (!id) return false;
+
+    const offerIds = (g.choiceCtx as any)?.offerIds as string[] | undefined;
+    if (offerIds && offerIds.length > 0 && !offerIds.includes(id)) return false;
+
+    g.run.relics ??= [];
+    if (!g.run.relics.includes(id)) grantRelic(g, id);
+
+    logMsg(g, `Ïú†Î¨º ÌöçÎìù: ${RELICS_BY_ID[id]?.name ?? id}`);
+    closeChoice(g);
+    return true;
+  }
+
+
+  if (key.startsWith("slot:")) {
+    const ctx: any = g.choiceCtx as any;
+    if (ctx?.kind !== "BOSS_SLOT_UPGRADE") return false;
+
+    const side = key.slice("slot:".length);
+    const runAny: any = g.run as any;
+    runAny.slotCapFront = Math.max(3, Math.min(4, Math.floor(Number(runAny.slotCapFront ?? 3))));
+    runAny.slotCapBack  = Math.max(3, Math.min(4, Math.floor(Number(runAny.slotCapBack  ?? 3))));
+
+    if (side === "front") {
+      if (runAny.slotCapFront < 4) runAny.slotCapFront += 1;
+      runAny.bossSlotFirstPick = "front";
+      pushUiToast(g, "INFO", "Î≥¥Ïä§ Î≥¥ÏÉÅ: Ï†ÑÏó¥ Ïä¨Î°Ø +1", 2000);
+      logMsg(g, "Î≥¥Ïä§ Î≥¥ÏÉÅ: Ï†ÑÏó¥ Ïä¨Î°Ø +1");
+      closeChoice(g);
+      return true;
+    }
+
+    if (side === "back") {
+      if (runAny.slotCapBack < 4) runAny.slotCapBack += 1;
+      runAny.bossSlotFirstPick = "back";
+      pushUiToast(g, "INFO", "Î≥¥Ïä§ Î≥¥ÏÉÅ: ÌõÑÏó¥ Ïä¨Î°Ø +1", 2000);
+      logMsg(g, "Î≥¥Ïä§ Î≥¥ÏÉÅ: ÌõÑÏó¥ Ïä¨Î°Ø +1");
+      closeChoice(g);
+      return true;
+    }
+
+    return false;
+  }
+
+  return false;
+}
+
+export function openRelicOfferChoice(
+  g: GameState,
+  opt: {
+    count: number;
+    title: string;
+    prompt: string;
+    allowSkip?: boolean;
+    source?: "BOSS" | "ELITE" | "PAID" | string;
+    artKeyOrPath?: string;
+  }
+) {
+  const roll = offerRelicSingleContent(g, opt.count);
+  if (!roll || roll.choices.length === 0) return null;
+
+  const offerIds = roll.choices.map((x) => x.id);
+
+  const options = roll.choices.map((r) => {
+    const def: any = RELICS_BY_ID[r.id];
+    const isLocked = !!def?.unlock;
+
+    const displayName = isLocked
+      ? (def?.dormantName ?? def?.name ?? r.id)
+      : (def?.name ?? r.id);
+
+    const displayDesc = isLocked
+      ? [def?.dormantText, def?.unlockHint].filter(Boolean).join("\n \n")
+      : (def?.text ?? "");
+
+    return {
+      key: `relic:${r.id}`,
+      label: displayName,
+      detail: `${displayName}\n\n${displayDesc}`,
+    };
+  });
+
+  if (opt.allowSkip) options.push({ key: "skip", label: "ÏÉùÎûµ", detail: "" });
+
+  const choice: ChoiceState = {
+    kind: "REWARD",
+    title: opt.title,
+    prompt: opt.prompt,
+    options,
+  };
+
+  // ÏÑ†ÌÉù ÌôîÎ©¥ ÏùºÎü¨Ïä§Ìä∏ (Ïòà: Î≥¥Ïä§ Ïú†Î¨º ÏÑ†ÌÉù)
+  if (opt.artKeyOrPath) {
+    const k = String(opt.artKeyOrPath);
+    const art = (k.includes("/") || k.includes("\\") || k.includes(".")) ? k : `assets/ui/${k}.png`;
+    (choice as any).art = art;
+  }
+
+  enqueueChoice(g, choice, { kind: "RELIC_OFFER", offerIds, source: opt.source });
+  return offerIds;
+}
+
+
+export function openBossSlotUpgradeChoice(g: GameState) {
+  const runAny: any = g.run as any;
+  const frontCap = Math.max(3, Math.min(4, Math.floor(Number(runAny.slotCapFront ?? 3))));
+  const backCap  = Math.max(3, Math.min(4, Math.floor(Number(runAny.slotCapBack  ?? 3))));
+
+  // Ïù¥ÎØ∏ Îëò Îã§ 4Î©¥ Ïä§ÌÇµ
+  if (frontCap >= 4 && backCap >= 4) return;
+
+  const options: ChoiceOption[] = [
+    {
+      key: "slot:front",
+      label: "Ï†ÑÏó¥ Ïä¨Î°Ø +1",
+      detail: "Ï†ÑÏó¥ Ïä¨Î°ØÏù¥ 1Ïπ∏ Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (ÏµúÎåÄ 4)
+
+Ï†ÑÏó¥ÏùÄ Ïú†ÏßÄÎπÑ(S)Î•º ÏÜåÎ™®Ìï©ÎãàÎã§.",
+    },
+    {
+      key: "slot:back",
+      label: "ÌõÑÏó¥ Ïä¨Î°Ø +1",
+      detail: "ÌõÑÏó¥ Ïä¨Î°ØÏù¥ 1Ïπ∏ Ï¶ùÍ∞ÄÌï©ÎãàÎã§. (ÏµúÎåÄ 4)
+
+ÌõÑÏó¥ÏùÄ ÍµêÎûÄ(disrupt)Ïùò ÏòÅÌñ•ÏùÑ Î∞õÏäµÎãàÎã§.",
+    },
+  ];
+
+  const choice: ChoiceState = {
+    kind: "REWARD",
+    title: "Î≥¥Ïä§ Î≥¥ÏÉÅ: ÏßÑÌòï ÌôïÏû•",
+    prompt: "Ï†ÑÏó¥ ÎòêÎäî ÌõÑÏó¥ Ïä¨Î°ØÏùÑ 1Ïπ∏ ÌôïÏû•Ìï©ÎãàÎã§.",
+    options,
+  };
+
+  enqueueChoice(g, choice, { kind: "BOSS_SLOT_UPGRADE" });
+}
+
+export function openBossRelicOfferChoice(g: GameState) {
+  return openRelicOfferChoice(g, {
+    count: 3,
+    title: "Î≥¥Ïä§ Î≥¥ÏÉÅ: Ïú†Î¨º",
+    prompt: "Ïú†Î¨º 1Í∞úÎ•º ÏÑ†ÌÉùÌï©ÎãàÎã§.",
+    allowSkip: false,
+    source: "BOSS",
+    artKeyOrPath: "what_to_do",
+  });
+}
+
+// =========================
+// Shop
+// =========================
+
+const randInt = (min: number, max: number) => min + Math.floor(Math.random() * (max - min + 1));
+
+const cardBasePrice = (rarity: string) => {
+  switch (rarity) {
+    case "SPECIAL": return 20;
+    case "RARE": return 30;
+    case "COMMON":
+    default: return 10;
+  }
+};
+
+function ensureShopState(g: GameState, nodeId: string): ShopState {
+  const runAny = g.run as any;
+  runAny.shops ??= {};
+  const existing = runAny.shops[nodeId] as ShopState | undefined;
+  if (existing) return existing;
+
+    // ÏÉÅÏ†ê Ïπ¥Îìú ÌíÄ: REWARD_POOLÏóêÏÑú weight>0Ïù∏ Ïπ¥ÎìúÎßå (Ï†ÄÏ£º/ÎØ∏ÏÇ¨Ïö© Ïπ¥Îìú Î∞©ÏßÄ)
+  const weightedIds = REWARD_POOL.filter((e) => (e.weight ?? 0) > 0).map((e) => e.id);
+
+  const allCardIds = (weightedIds.length > 0 ? weightedIds : Object.keys(g.content.cardsById))
+    .filter((id) => {
+      const base = g.content.cardsById[id];
+      const r = (base?.rarity ?? "COMMON");
+      return r !== "BASIC" && r !== "MADNESS";
+    });
+  const picks: string[] = [];
+
+  const want = 6;
+  let tries = 0;
+  while (picks.length < want && tries++ < 200) {
+    const id = allCardIds[Math.floor(Math.random() * allCardIds.length)];
+    if (!id) continue;
+    if (picks.includes(id) && Math.random() < 0.8) continue;
+    picks.push(id);
+  }
+
+  const cards: ShopCardOffer[] = picks.map((defId) => {
+    const base = g.content.cardsById[defId];
+    const r = (base?.rarity ?? "COMMON");
+    const price = Math.max(1, cardBasePrice(r) + randInt(-2, 2));
+    return { defId, upgrade: 0, priceGold: price, sold: false };
+  });
+
+  const items = (() => {
+    const ids = ITEMS.map((x) => x.id);
+    const wantI = 2;
+    const picksI: string[] = [];
+    let triesI = 0;
+    while (picksI.length < wantI && triesI++ < 80 && ids.length > 0) {
+      const id = ids[Math.floor(Math.random() * ids.length)];
+      if (!id) continue;
+      if (picksI.includes(id) && Math.random() < 0.85) continue;
+      picksI.push(id);
+    }
+
+    return picksI.map((itemId) => {
+      const def = getItemDefById(itemId);
+      const base = Number(def?.priceGold ?? 18) || 18;
+      const price = Math.max(1, base + randInt(-2, 2));
+      return { itemId, priceGold: price, sold: false };
+    });
+  })();
+
+  const st: ShopState = {
+    nodeId,
+    cards,
+    items,
+    usedUpgrade: false,
+    usedRemove: false,
+    createdAtMove: Number((g.run as any).timeMove ?? 0) || 0,
+    art: "assets/ui/background/shop_bg.png",
+  };
+
+  runAny.shops[nodeId] = st;
+  return st;
+}
+
+export function openShopChoice(g: GameState, nodeId: string) {
+  const shop = ensureShopState(g, nodeId);
+
+  // shop visit toasts (1Ìöå)
+  if (getPatronGodOrNull(g) === "first_human" && !(shop as any)._firstHumanShopToastShown) {
+    (shop as any)._firstHumanShopToastShown = true;
+    pushUiToast(g, "WARN", GOD_LINES.first_human.shop, 2200);
+    logMsg(g, GOD_LINES.first_human.shop);
+  }
+  if (isHostile(g, "card_dealer") && !(shop as any)._cardDealerHostileShopToastShown) {
+    (shop as any)._cardDealerHostileShopToastShown = true;
+    pushUiToast(g, "WARN", GOD_LINES.card_dealer.hostileShop, 2200);
+    logMsg(g, GOD_LINES.card_dealer.hostileShop);
+  }
+
+  const options: ChoiceOption[] = [];
+  let sep = 0;
+
+  // Ïπ¥Îìú ÌåêÎß§
+  for (let i = 0; i < shop.cards.length; i++) {
+    const o = shop.cards[i];
+    const base = g.content.cardsById[o.defId];
+    const name = base?.name ?? o.defId;
+    const upTxt = (o.upgrade ?? 0) > 0 ? ` +${o.upgrade}` : "";
+
+    if (o.sold) {
+      options.push({ key: `shop:card:${i}`, label: `${name}${upTxt} (ÌíàÏ†à)`, detail: "" });
+      continue;
+    }
+
+    const priceGold = shopPriceGold(g, o.priceGold);
+    const def = getCardDefByIdWithUpgrade(g.content, o.defId, o.upgrade ?? 0);
+    const detail = `Í∞ÄÍ≤©: ü™ô${priceGold}
+
+Ï†ÑÏó¥: ${def.frontText}
+ÌõÑÏó¥: ${def.backText}`;
+    options.push({ key: `shop:card:${i}`, label: `${name}${upTxt} (ü™ô${priceGold})`, detail });
+  }
+
+  options.push({ key: `shop:sep:${sep++}`, label: "‚Äî", detail: "" });
+
+  // ÏïÑÏù¥ÌÖú ÌåêÎß§
+  if (shop.items && shop.items.length > 0) {
+    for (let i = 0; i < shop.items.length; i++) {
+      const it = shop.items[i];
+      const def = getItemDefById(it.itemId);
+      const name = def?.name ?? it.itemId;
+
+      if (it.sold) {
+        options.push({ key: `shop:item:${i}`, label: `${name} (ÌíàÏ†à)`, detail: "" });
+        continue;
+      }
+
+      const priceGold = shopPriceGold(g, it.priceGold);
+      const detail = `Í∞ÄÍ≤©: ü™ô${priceGold}\n\n${def?.text ?? ""}`;
+      options.push({ key: `shop:item:${i}`, label: `${name} (ü™ô${priceGold})`, detail });
+    }
+
+    options.push({ key: `shop:sep:${sep++}`, label: "‚Äî", detail: "" });
+  }
+
+  // ÏÑúÎπÑÏä§/Î≥¥Í∏â
+  const upLabel = shop.usedUpgrade ? "Ïπ¥Îìú Í∞ïÌôî (ÏÇ¨Ïö© ÏôÑÎ£å)" : "Ïπ¥Îìú Í∞ïÌôî";
+  const rmLabel = shop.usedRemove ? "Ïπ¥Îìú Ï†úÍ±∞ (ÏÇ¨Ïö© ÏôÑÎ£å)" : "Ïπ¥Îìú Ï†úÍ±∞";
+
+  const upPrice = shopPriceGold(g, 25);
+  const rmPrice = shopPriceGold(g, 25);
+  const buySPrice = shopPriceGold(g, 6);
+
+  options.push({ key: "shop:service:upgrade", label: upLabel, detail: shop.usedUpgrade ? "" : `Í∞ÄÍ≤©: ü™ô${upPrice} Ïπ¥Îìú 1Ïû•ÏùÑ Í∞ïÌôîÌï©ÎãàÎã§.` });
+  options.push({ key: "shop:service:remove", label: rmLabel, detail: shop.usedRemove ? "" : `Í∞ÄÍ≤©: ü™ô${rmPrice} Îç±ÏóêÏÑú Ïπ¥Îìú 1Ïû•ÏùÑ Ï†úÍ±∞Ìï©ÎãàÎã§.` });
+  options.push({ key: "shop:supply:buy", label: "Î≥¥Í∏â Íµ¨Îß§", detail: `-ü™ô${buySPrice}, Îã§Ïùå Ï†ÑÌà¨ Î≥¥Í∏â üçû +3` });
+  options.push({ key: "shop:supply:sell", label: "Î≥¥Í∏â ÌåêÎß§", detail: "Îã§Ïùå Ï†ÑÌà¨ Î≥¥Í∏â üçû -3, +ü™ô4" });
+
+  options.push({ key: "shop:leave", label: "ÎÇòÍ∞ÄÍ∏∞", detail: "" });
+
+  {
+    const seen = new Set<string>();
+    const dups: string[] = [];
+    for (const o of options) {
+      if (seen.has(o.key)) dups.push(o.key);
+      seen.add(o.key);
+    }
+    if (dups.length) {
+      logMsg(g, `Í≤ΩÍ≥†: ÏÉÅÏ†ê ÏÑ†ÌÉùÌÇ§ Ï§ëÎ≥µ: ${dups.join(", ")}`);
+    }
+  }
+
+  const choice: ChoiceState = {
+    kind: "EVENT",
+    title: "Í≥†Î∏îÎ¶∞Ïùò ÏÉÅÏ†ê",
+    prompt: "Ïò®Í±¥Ìåå Í≥†Î∏îÎ¶∞Ïùò ÏÉÅÏ†êÏûÖÎãàÎã§.",
+    options,
+  };
+
+  if (shop.art) (choice as any).art = shop.art;
+
+  g.choiceQueue = [];
+  g.choiceStack = [];
+  g.choice = choice;
+  g.choiceCtx = { kind: "SHOP", nodeId } as any;
+  if (shop.art) (choice as any).art = shop.art;
+}
diff -ruN /src/engine/state.ts /src/engine/state.ts
--- /src/engine/state.ts	2026-02-24 03:36:46.000000000 +0000
+++ /src/engine/state.ts	2026-02-24 11:59:22.429425272 +0000
@@ -26,6 +26,12 @@
     },
 
     timeMove: 0,
+    // Ïä¨Î°Ø ÌôïÏû•(Î≥¥Ïä§ Î≥¥ÏÉÅ)
+    slotCapFront: 3,
+    slotCapBack: 3,
+    bossKillCount: 0,
+    bossSlotFirstPick: null,
+
     map: generateDungeonMap(),
     pursuit: { heat: 0 },
     vision: { mode: "NORMAL", blind: false, presenceR: 2, typeR: 2, detailR: 0, noise: 0 },
diff -ruN /src/engine/types.ts /src/engine/types.ts
--- /src/engine/types.ts	2026-02-24 09:39:19.000000000 +0000
+++ /src/engine/types.ts	2026-02-24 11:59:22.429716921 +0000
@@ -443,6 +443,12 @@
 
   timeMove: number;
 
+  // Ïä¨Î°Ø ÌôïÏû•(Î≥¥Ïä§ Î≥¥ÏÉÅ)
+  slotCapFront?: number; // Í∏∞Î≥∏ 3, ÏµúÎåÄ 4
+  slotCapBack?: number;  // Í∏∞Î≥∏ 3, ÏµúÎåÄ 4
+  bossKillCount?: number;
+  bossSlotFirstPick?: "front" | "back" | null;
+
   map: DungeonMap;
 
   pursuit: PursuitState;
@@ -532,6 +538,7 @@
   | { kind: "ITEM_REWARD"; offerId: ItemId; source?: "BATTLE" | "ELITE" | "BOSS" | string }
   | { kind: "REST"; highF?: boolean }
   | { kind: "EVENT"; eventId: string }
+  | { kind: "BOSS_SLOT_UPGRADE" }
   | { kind: "RELIC_OFFER"; offerIds: string[]; source?: "BOSS" | "ELITE" | "PAID" | string }
   | { kind: "SHOP"; nodeId: string }
   | { kind: "UPGRADE_PICK"; returnTo?: { kind: "SHOP"; nodeId: string }; priceGold?: number }
diff -ruN /src/style.css /src/style.css
--- /src/style.css	2026-02-24 08:48:57.000000000 +0000
+++ /src/style.css	2026-02-24 11:59:22.436755887 +0000
@@ -600,6 +600,22 @@
   --slotTextScale: 0.78;
 }
 
+/* Ïä¨Î°Ø Ïû†Í∏à(Î≥¥Ïä§ Î≥¥ÏÉÅ Ïä¨Î°Ø ÌôïÏû• Ï†Ñ) */
+.slot.locked{
+  opacity: 0.38;
+}
+.slot .slotLock{
+  position: absolute;
+  inset: 0;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  font-size: calc(26 * var(--u));
+  pointer-events: none;
+  text-shadow: 0 2px 6px rgba(0,0,0,0.55);
+}
+
+
 /* Ïä¨Î°Ø ÏïàÏóêÏÑú Ï†ïÏ§ëÏïô Î∞∞Ïπò Ïª®ÌÖåÏù¥ÎÑà */
 .slotCardScaler{
   position: absolute;
diff -ruN /src/ui/ui.ts /src/ui/ui.ts
--- /src/ui/ui.ts	2026-02-24 10:11:50.000000000 +0000
+++ /src/ui/ui.ts	2026-02-24 11:59:22.435090986 +0000
@@ -7089,15 +7089,29 @@
   const hasSelected = !!g.selectedHandCardUid;
   const slots = side === "front" ? g.frontSlots : g.backSlots;
 
-  for (let i = 0; i < 3; i++) {
+
+  const runAny: any = g.run as any;
+  const capRaw = Number(side === "front" ? runAny.slotCapFront : runAny.slotCapBack);
+  const cap = Math.max(3, Math.min(4, Math.floor(Number.isFinite(capRaw) ? capRaw : 3)));
+
+  for (let i = 0; i < slots.length; i++) {
     const disabled = side === "back" ? !!g.backSlotDisabled?.[i] : false;
+    const locked = i >= cap;
 
-    const s = div("slot" + (disabled ? " disabled" : ""));
+    const s = div("slot" + (disabled ? " disabled" : "") + (locked ? " locked" : ""));
     s.dataset.slotSide = side;
     s.dataset.slotIndex = String(i);
 
+    if (locked) {
+      const lk = div("slotLock");
+      lk.textContent = "üîí";
+      s.appendChild(lk);
+      grid.appendChild(s);
+      continue;
+    }
+
     if (hoverSlot && hoverSlot.side === side && hoverSlot.idx === i) s.classList.add("dropHover");
-    if (hasSelected && !disabled) s.classList.add("placeable");
+    if (hasSelected && !disabled && !locked) s.classList.add("placeable");
 
     const uid = slots[i];
     if (uid) {
@@ -7470,6 +7484,11 @@
   const side = slot.dataset.slotSide as Side;
   const idx = Number(slot.dataset.slotIndex);
 
+  const runAny: any = g.run as any;
+  const capRaw = Number(side === "front" ? runAny.slotCapFront : runAny.slotCapBack);
+  const cap = Math.max(3, Math.min(4, Math.floor(Number.isFinite(capRaw) ? capRaw : 3)));
+  if (idx < 0 || idx >= cap) return null;
+
   if (side === "back" && g.backSlotDisabled?.[idx]) return null;
   return { side, idx };
 }
