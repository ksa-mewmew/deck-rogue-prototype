(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))a(r);new MutationObserver(r=>{for(const o of r)if(o.type==="childList")for(const l of o.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&a(l)}).observe(document,{childList:!0,subtree:!0});function t(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?o.credentials="include":r.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function a(r){if(r.ep)return;r.ep=!0;const o=t(r);fetch(r.href,o)}})();function ae(e){return[{id:"A",type:e[0]},{id:"B",type:e[1]}]}function de(e,n,t){e.status[n]=Math.max(0,(e.status[n]??0)+t)}function V(e){const n=ae(re(e)),t=ae(re(e)),a=ae(re(e));return{root:n,nextIfA:t,nextIfB:a}}function Re(e,n){e.run.branchOffer||(e.run.branchOffer=V(e));const t=e.run.branchOffer,a=n==="A"?t.nextIfA:t.nextIfB,r=V(e);e.run.branchOffer={root:a,nextIfA:r.nextIfA,nextIfB:r.nextIfB}}function ve(){return Math.random().toString(16).slice(2)+"-"+Date.now().toString(16)}function ne(e,n=0){return e<n?n:e}function Se(e){const n=[...e];for(let t=n.length-1;t>0;t--){const a=Math.floor(Math.random()*(t+1));[n[t],n[a]]=[n[a],n[t]]}return n}function O(e){return e[Math.floor(Math.random()*e.length)]}function s(e,n){e.log.unshift(n),e.log=e.log.slice(0,250)}function P(e){return e.enemies.filter(n=>n.hp>0)}function De(e,n,t){e.status[n]=ne((e.status[n]??0)+t,0)}function re(e){if((e.run.nodePickCount+1)%30===0)return["BATTLE","BATTLE"];const t=[],a=e.run.treasureObtained?25:24,r=e.run.treasureObtained?1:3,o=e.run.treasureObtained?7:5,f=!e.run.treasureObtained&&e.run.nodePickCount>=30?1:0;for(let d=0;d<a;d++)t.push("BATTLE");for(let d=0;d<r;d++)t.push("REST");for(let d=0;d<o;d++)t.push("EVENT");for(let d=0;d<f;d++)t.push("TREASURE");const u=O(t);let c=O(t);if(u==="TREASURE"&&c==="TREASURE"){let d=0;do if(c=O(t),d++,d>50)break;while(c==="TREASURE")}return[u,c]}function Pe(e){const n={phase:"NODE",log:[],uidSeq:0,winHooksAppliedThisCombat:!1,intentsRevealedThisTurn:!1,disruptIndexThisTurn:null,backUidsThisTurn:[],run:{encounterCount:0,treasureObtained:!1,afterTreasureNodePicks:0,finished:!1,nextBattleSuppliesBonus:0,bossPool:["boss_cursed_wall","boss_giant_orc","boss_soul_stealer"],nodePickCount:0,branchOffer:null,nodeOfferQueue:[],currentNodeOffers:null,nodePickByType:{BATTLE:0,REST:0,EVENT:0,TREASURE:0},battleCount:0,enemyLastSeenBattle:{}},player:{hp:40,maxHp:40,block:0,supplies:0,fatigue:0,zeroSupplyTurns:0,status:{vuln:0,weak:0,bleed:0,disrupt:0},immuneToDisruptThisTurn:!1,nullifyDamageThisTurn:!1},content:e,cards:{},deck:[],hand:[],discard:[],exhausted:[],vanished:[],choice:null,choiceStack:[],frontSlots:[null,null,null],backSlots:[null,null,null],backSlotDisabled:[!1,!1,!1],enemies:[],attackedEnemyIndicesThisTurn:[],usedThisTurn:0,frontPlacedThisTurn:0,selectedHandCardUid:null,pendingTargetQueue:[],pendingTarget:null,drawCountThisTurn:0};return n.run.branchOffer=V(n),Le(n),s(n,"새 런 시작. 다음 인카운터를 선택하세요."),n}function F(e,n,t){for(let a=0;a<t;a++){const r=ve(),o={uid:r,defId:n,zone:"deck",upgrade:0};e.cards[r]=o,e.deck.push(r)}}function Le(e){F(e,"field_ration",2),F(e,"maintenance",2),F(e,"scout",2),F(e,"shield",2),F(e,"power_arrow",1),F(e,"arrow",3),e.deck=Se(e.deck)}function w(e,n){const t=e.cards[n],a=e.content.cardsById[t.defId],r=t.upgrade??0,o=a.upgrades?.[r-1];return o?{...a,...o}:a}function v(e,n,t){const a=e.cardsById[n],r=Math.max(0,t|0);if(r<=0)return a;const o=a.upgrades?.[r-1];return o?{...a,...o}:a}function I(e,n){const a=e.cards[n].upgrade??0,r=w(e,n);return a>0?`${r.name} +${a}`:r.name}const We=[{id:"field_ration",name:"야전 식량",frontText:"방어 +3",backText:"S +2",front:[{op:"block",n:3}],back:[{op:"supplies",n:2}],upgrades:[{frontText:"방어 +5",front:[{op:"block",n:5}],backText:"S +3",back:[{op:"supplies",n:3}]}]},{id:"maintenance",name:"정비 도구",tags:["EXHAUST"],exhaustWhen:"BACK",frontText:"방어 +3",backText:"F -1, 소모",front:[{op:"block",n:3}],back:[{op:"fatigue",n:-1}],upgrades:[{frontText:"방어 +5",front:[{op:"block",n:5}],backText:"F -1, S +1, 소모",back:[{op:"fatigue",n:-1},{op:"supplies",n:1}]}]},{id:"scout",name:"정찰",frontText:"선택한 적에게 3 피해, 방어 +2",backText:"드로우 1, 손패 크기 +1, S +2",front:[{op:"damageEnemy",target:"select",n:3},{op:"block",n:2}],back:[{op:"draw",n:1},{op:"supplies",n:2}],upgrades:[{frontText:"선택한 적에게 4 피해, 방어 +3",front:[{op:"damageEnemy",target:"select",n:3},{op:"block",n:2}],backText:"드로우 2, 손패 크기 +2, S +2",back:[{op:"draw",n:2},{op:"supplies",n:2}]}]},{id:"shield",name:"방패",frontText:"방어 +6",backText:"방어 +3",front:[{op:"block",n:6}],back:[{op:"block",n:3}],upgrades:[{frontText:"방어 +8",front:[{op:"block",n:8}],backText:"방어 +4",back:[{op:"block",n:4}]}]},{id:"power_arrow",name:"강력한 화살",frontText:"무작위 적에게 10 피해, S -1",backText:"무작위 적에게 전열 한 장당 2 피해, S -1",front:[{op:"supplies",n:-1},{op:"damageEnemy",target:"random",n:10}],back:[{op:"supplies",n:-1},{op:"damageEnemyBy",target:"random",nPer:2,by:"frontCount"}],upgrades:[{frontText:"무작위 적에게 13 피해, S -1",front:[{op:"supplies",n:-1},{op:"damageEnemy",target:"random",n:13}],backText:"무작위 적에게 전열 한 장당 2 피해",back:[{op:"damageEnemyBy",target:"random",nPer:2,by:"frontCount"}]}]},{id:"arrow",name:"화살",frontText:"선택한 적에게 5 피해",backText:"선택한 적에게 5 피해, S -1",front:[{op:"damageEnemy",target:"select",n:5}],back:[{op:"supplies",n:-1},{op:"damageEnemy",target:"select",n:5}],upgrades:[{frontText:"선택한 적에게 7 피해",front:[{op:"damageEnemy",target:"select",n:7}],backText:"선택한 적에게 7 피해, S -1",back:[{op:"supplies",n:-1},{op:"damageEnemy",target:"select",n:7}]}]},{id:"goal_treasure",name:"저주받은 보물",tags:["EXHAUST"],exhaustWhen:"BOTH",frontText:"F +1, 소모",backText:"S -1, F +1, 소모",front:[{op:"fatigue",n:1}],back:[{op:"supplies",n:-1},{op:"fatigue",n:1}]},{id:"berserk",name:"광폭화",frontText:"무작위 적에게 15 피해, F +1",backText:"S +4, F +1",front:[{op:"damageEnemy",target:"random",n:15},{op:"fatigue",n:1}],back:[{op:"supplies",n:4},{op:"fatigue",n:1}],upgrades:[{frontText:"무작위 적에게 20 피해, F +2",front:[{op:"damageEnemy",target:"random",n:20},{op:"fatigue",n:2}],backText:"S +6, F +2",back:[{op:"supplies",n:6},{op:"fatigue",n:2}]}]},{id:"bandage",name:"붕대",frontText:"HP +4",backText:"HP +4, S -1",front:[{op:"heal",n:4}],back:[{op:"supplies",n:-1},{op:"heal",n:4}],upgrades:[{frontText:"HP +4, 출혈 제거",front:[{op:"heal",n:4},{op:"clearStatusSelf",key:"bleed"}],backText:"HP +4, 출혈 제거, S -1",back:[{op:"supplies",n:-1},{op:"heal",n:4},{op:"clearStatusSelf",key:"bleed"}]}]},{id:"arrow_rain",name:"화살의 비",tags:["EXHAUST"],exhaustWhen:"BOTH",frontText:"모든 적에게 10 피해, S -1, F +1, 소모",backText:"드로우 2, 손패 크기 +2, S +2, F +1, 소모",front:[{op:"damageEnemy",target:"all",n:10},{op:"supplies",n:-1},{op:"fatigue",n:1}],back:[{op:"draw",n:2},{op:"supplies",n:2},{op:"fatigue",n:1}],upgrades:[{frontText:"모든 적에게 13 피해, S -2, F +1, 소모",front:[{op:"damageEnemy",target:"all",n:13},{op:"supplies",n:-2},{op:"fatigue",n:1}],backText:"드로우 3, 손패 크기 +3, S +3, F +2, 소모",back:[{op:"draw",n:3},{op:"supplies",n:3},{op:"fatigue",n:2}]}]},{id:"smoke",name:"연막",tags:["EXHAUST"],exhaustWhen:"FRONT",frontText:"이번 턴 피해 무효, 소모",backText:"자신은 교란 당하지 않음",front:[{op:"nullifyDamageThisTurn"}],back:[{op:"immuneDisruptThisTurn"}]},{id:"redeploy",name:"재배치",frontText:"S +2",backText:"3번 슬롯에 있는 후열 카드의 전열 효과 발동",front:[{op:"supplies",n:2}],back:[{op:"triggerFrontOfBackSlot",index:2}],upgrades:[{frontText:"S +3",front:[{op:"supplies",n:3}],backText:"3번 슬롯에 있는 후열 카드의 전열 효과 발동, S +1",back:[{op:"triggerFrontOfBackSlot",index:2},{op:"supplies",n:1}]}]},{id:"secret_strike",name:"비장의 일격",tags:["EXHAUST"],exhaustWhen:"BOTH",frontText:"무작위 적에게 자신의 F의 3배 피해, 소모",backText:"모든 적에게 취약 +4 및 약화 +4, 소모",front:[{op:"damageEnemyByPlayerFatigue",target:"random",mult:3}],back:[{op:"statusEnemy",target:"all",key:"vuln",n:4},{op:"statusEnemy",target:"all",key:"weak",n:4}],upgrades:[{tags:["EXHAUST"],exhaustWhen:"FRONT",frontText:"선택한 적에게 자신의 F의 3배 피해, 소모",front:[{op:"damageEnemyByPlayerFatigue",target:"select",mult:3}],backText:"모든 적에게 취약 +4 및 약화 +4",back:[{op:"statusEnemy",target:"all",key:"vuln",n:4},{op:"statusEnemy",target:"all",key:"weak",n:4}]}]},{id:"fire_scroll",name:"화염 두루마리",tags:["EXHAUST"],exhaustWhen:"BOTH",frontText:"방어 +7, 소모",backText:"모든 적에게 12 피해, 소모",front:[{op:"block",n:7}],back:[{op:"damageEnemy",target:"all",n:12}],upgrades:[{frontText:"방어 +8, 소모",front:[{op:"block",n:8}],backText:"모든 적에게 14 피해, 소모",back:[{op:"damageEnemy",target:"all",n:14}]}]},{id:"caltrops",name:"마름쇠",frontText:"모든 적에게 출혈 4 부여",backText:"이번 턴에 자신을 공격하려는 적에게 출혈 3 부여",front:[{op:"statusEnemy",target:"all",key:"bleed",n:4}],back:[{op:"statusEnemiesAttackingThisTurn",key:"bleed",n:3}],upgrades:[{frontText:"모든 적에게 출혈 5 부여",backText:"이번 턴에 자신을 공격하려는 적에게 출혈 4 부여",front:[{op:"statusEnemy",target:"all",key:"bleed",n:5}],back:[{op:"statusEnemiesAttackingThisTurn",key:"bleed",n:4}]}]},{id:"emergency_rations",name:"비상식량",tags:["VANISH"],vanishWhen:"BACK",frontText:"S +2",backText:"S를 10으로 만듦. 소실",front:[{op:"supplies",n:2}],back:[{op:"setSupplies",n:10}],upgrades:[{frontText:"S +3",backText:"S를 15으로 만듦. 소실",front:[{op:"supplies",n:3}],back:[{op:"setSupplies",n:15}]}]},{id:"painkiller",name:"진통제",tags:["EXHAUST"],exhaustWhen:"BOTH",frontText:"HP -8, F -2, 소모",backText:"HP +10, F +2, 소모",front:[{op:"hp",n:-8},{op:"fatigue",n:-2}],back:[{op:"hp",n:10},{op:"fatigue",n:2}],upgrades:[{frontText:"HP -5, F -2, 소모",backText:"HP +10, F +1, 소모",front:[{op:"hp",n:-5},{op:"fatigue",n:-2}],back:[{op:"hp",n:10},{op:"fatigue",n:1}]}]},{id:"field_experience",name:"실전 경험",tags:["EXHAUST"],exhaustWhen:"BACK",frontText:"모든 적에게 3 피해",backText:"이 카드가 후열에 있는 턴에 승리하면 최대 체력 +2, 소모",front:[{op:"damageEnemy",target:"all",n:3}],back:[],onWinWhileInBack:[{op:"maxHp",n:2}],upgrades:[{frontText:"모든 적에게 4 피해",backText:"이 카드가 후열에 있는 턴에 승리하면 최대 체력 +3, 소모",front:[{op:"damageEnemy",target:"all",n:4}],onWinWhileInBack:[{op:"maxHp",n:3}]}]},{id:"camp_prep",name:"야영 준비",frontText:"방어 +4, S +1",backText:"S +3",front:[{op:"block",n:4},{op:"supplies",n:1}],back:[{op:"supplies",n:3}],upgrades:[{frontText:"방어 +5, S +2",backText:"S +5",front:[{op:"block",n:5},{op:"supplies",n:2}],back:[{op:"supplies",n:5}]}]},{id:"vital_shot",name:"급소 사격",frontText:"선택한 적에게 8 피해",backText:"선택한 적에게 5 피해, 출혈 2 부여, S -1",front:[{op:"damageEnemy",target:"select",n:8}],back:[{op:"supplies",n:-1},{op:"damageEnemy",target:"select",n:5},{op:"statusEnemy",target:"select",key:"bleed",n:2}],upgrades:[{frontText:"선택한 적에게 11 피해",backText:"선택한 적에게 6 피해, 출혈 3 부여, S -1",front:[{op:"damageEnemy",target:"select",n:11}],back:[{op:"supplies",n:-1},{op:"damageEnemy",target:"select",n:6},{op:"statusEnemy",target:"select",key:"bleed",n:3}]}]},{id:"taunt",name:"독설",frontText:"선택한 적에게 약화 +4",backText:"모든 적에게 취약 +2 및 약화 +2",front:[{op:"statusEnemy",target:"select",key:"weak",n:4}],back:[{op:"statusEnemy",target:"all",key:"vuln",n:2},{op:"statusEnemy",target:"all",key:"weak",n:2}],upgrades:[{frontText:"선택한 적에게 약화 +5",backText:"모든 적에게 취약 +2 및 약화 +3",front:[{op:"statusEnemy",target:"select",key:"weak",n:5}],back:[{op:"statusEnemy",target:"all",key:"vuln",n:2},{op:"statusEnemy",target:"all",key:"weak",n:3}]}]},{id:"rapid_fire",name:"연속 사격",frontText:"선택한 적에게 2 피해, 3번 발동",backText:"이번 턴에 카드를 뽑았으면 무작위 적에게 8 피해",front:[{op:"damageEnemy",target:"select",n:2},{op:"damageEnemy",target:"select",n:2},{op:"damageEnemy",target:"select",n:2}],back:[{op:"ifDrewThisTurn",then:[{op:"damageEnemy",target:"random",n:8}]}],upgrades:[{frontText:"선택한 적에게 2 피해, 4번 발동",backText:"이번 턴에 카드를 뽑았으면 무작위 적에게 10 피해",front:[{op:"damageEnemy",target:"select",n:2},{op:"damageEnemy",target:"select",n:2},{op:"damageEnemy",target:"select",n:2},{op:"damageEnemy",target:"select",n:2}],back:[{op:"ifDrewThisTurn",then:[{op:"damageEnemy",target:"random",n:10}]}]}]}],Fe=Object.fromEntries(We.map(e=>[e.id,e])),Me=[{id:"other_adventurer",name:"보물을 노리는 다른 모험가",maxHp:40,intents:[{label:"5 피해, 3번 발동",acts:[{op:"damagePlayer",n:5},{op:"damagePlayer",n:5},{op:"damagePlayer",n:5}]},{label:"출혈4, 취약4, 약화4",acts:[{op:"statusPlayer",key:"bleed",n:4},{op:"statusPlayer",key:"vuln",n:4},{op:"statusPlayer",key:"weak",n:4}]}]},{id:"goblin_raider",name:"고블린 약탈자",maxHp:15,intents:[{label:"(12-이번 턴에 사용한 카드의 수) 피해",acts:[{op:"damagePlayerFormula",kind:"goblin_raider"}]},{label:"S -4",acts:[{op:"supplies",n:-4}]}]},{id:"watching_statue",name:"감시하는 석상",maxHp:25,intents:[{label:"4+(이번 턴에 사용한 카드의 수) 피해",acts:[{op:"damagePlayerFormula",kind:"watching_statue"}]}]},{id:"pebble_golem",name:"조약돌 골렘",maxHp:25,intents:[{label:"6 피해",acts:[{op:"damagePlayer",n:6}]},{label:"자신 HP 6 회복",acts:[{op:"enemyHealSelf",n:6}]}]},{id:"rock_golem",name:"바위 골렘",maxHp:50,intents:[{label:"7 피해",acts:[{op:"damagePlayer",n:7}]},{label:"자신 HP 10 회복",acts:[{op:"enemyHealSelf",n:10}]}]},{id:"slime",name:"슬라임",maxHp:30,intents:[{label:"다음 턴 동안 피해를 입지 않음",acts:[{op:"enemyImmuneNextTurn"}]},{label:"약화 4 부여 후 자신 HP 3 회복",acts:[{op:"statusPlayer",key:"weak",n:4},{op:"enemyHealSelf",n:3}]},{label:"6 피해",acts:[{op:"damagePlayer",n:6}]}]},{id:"poison_spider",name:"독거미",maxHp:28,intents:[{label:"출혈 4 부여",acts:[{op:"statusPlayer",key:"bleed",n:4}]},{label:"7 피해",acts:[{op:"damagePlayer",n:7}]},{label:"출혈 2 부여, 6 피해)",acts:[{op:"statusPlayer",key:"bleed",n:2},{op:"damagePlayer",n:6}]}]},{id:"boss_cursed_wall",name:"저주받은 벽",maxHp:100,intents:[{label:"F += 1",acts:[{op:"fatiguePlayer",n:1}]},{label:"아무 행동도 하지 않음",acts:[]}]},{id:"boss_giant_orc",name:"거대한 오크",maxHp:70,intents:[{label:"15 피해",acts:[{op:"damagePlayer",n:15}]},{label:"다음 턴 동안 피해를 입지 않음",acts:[{op:"enemyImmuneNextTurn"}]},{label:"자신 HP 15 회복",acts:[{op:"enemyHealSelf",n:15}]}]},{id:"boss_soul_stealer",name:"영혼 강탈자",maxHp:50,intents:[{label:"7 피해, S -2",acts:[{op:"damagePlayer",n:7},{op:"supplies",n:-2}]},{label:"7 피해, F +1",acts:[{op:"damagePlayer",n:7},{op:"fatiguePlayer",n:1}]},{label:"카운트 진행",acts:[]}]}],Ue=Object.fromEntries(Me.map(e=>[e.id,e]));function Ke(e,n){n<=0||(e.player.block+=n,s(e,`방어(블록) +${n} (현재 ${e.player.block})`))}function ze(e,n){e.player.supplies=ne(e.player.supplies+n,0),s(e,`보급 S ${n>=0?"+":""}${n} (현재 ${e.player.supplies})`)}function Z(e,n){e.player.fatigue=ne(e.player.fatigue+n,0),s(e,`피로 F ${n>=0?"+":""}${n} (현재 ${e.player.fatigue})`)}function Ve(e,n){if(n<=0)return;const t=e.player.hp;e.player.hp=Math.min(e.player.maxHp,e.player.hp+n),s(e,`HP +${e.player.hp-t} (현재 ${e.player.hp}/${e.player.maxHp})`)}function Xe(e){P(e).length===0&&(e.pendingTarget=null,e.pendingTargetQueue=[])}function M(e,n,t){const a=e.enemies.indexOf(n);if(a>=0&&!e.attackedEnemyIndicesThisTurn.includes(a)&&e.attackedEnemyIndicesThisTurn.push(a),t<=0)return;const r=e.player.status.weak??0,o=n.status.vuln??0;if(n.immuneThisTurn){s(e,`적(${n.name})은(는) 이번 턴 피해 면역 → ${t} 피해 무시`);return}let l=t-r+o;l<0&&(l=0),n.hp-=l,n.hp<0&&(n.hp=0),s(e,`적(${n.name})에게 ${l} 피해. (HP ${n.hp}/${n.maxHp})`),Xe(e)}function g(e,n,t=null){if(n<=0)return;if(e.player.nullifyDamageThisTurn){s(e,`이번 턴 피해 무효(연막): ${n} 피해가 무시됨`);return}const a=t?.status.weak??0,r=e.player.status.vuln??0;let o=n-a+r;o<0&&(o=0);const l=Math.min(e.player.block,o);e.player.block-=l,o-=l,o>0&&(e.player.hp-=o),e.player.hp<0&&(e.player.hp=0),s(e,`플레이어 피해 → 블록 ${l} 흡수, 실제 ${o} 피해. (HP ${e.player.hp}/${e.player.maxHp}, 블록 ${e.player.block})`)}function je(){return he[Math.floor(Math.random()*he.length)]}const he=[{id:"drop_bag",name:"짐 버리기",prompt:"짐을 줄여 피로를 낮추자.",options:()=>[{key:"drop",label:"카드 1장 제거, F -= 1",apply:e=>(Z(e,-1),s(e,"이벤트: 짐 버리기 → 제거할 카드를 선택하세요."),{kind:"REMOVE_PICK",title:"짐 버리기",prompt:"제거할 카드 1장을 선택하세요.",then:"NONE"})},{key:"skip",label:"아무것도 하지 않는다",apply:e=>(s(e,"이벤트: 짐 버리기(생략)"),"NONE")}]},{id:"hide_from_monster",name:"몬스터로부터 숨기",prompt:"전투하거나, 대가를 치르고 숨을 수 있다.",options:()=>[{key:"fight",label:"전투",apply:e=>(s(e,"이벤트: 몬스터로부터 숨기 → 전투 선택"),"BATTLE")},{key:"remove_and_fatigue",label:"카드 1장 제거 후 F += 1",apply:e=>(Z(e,1),s(e,"이벤트: 몬스터로부터 숨기 → 카드 제거 후 F+1"),{kind:"REMOVE_PICK",title:"짐 버리기",prompt:"제거할 카드 1장을 선택하세요.",then:"NONE"})}]},{id:"overweight",name:"과중량",prompt:"너무 많은 짐이 피로를 부른다.",options:()=>[{key:"accept",label:"F += (덱 매수)/5 (버림)",apply:e=>{const n=Object.values(e.cards).filter(a=>["deck","hand","discard"].includes(a.zone)).length,t=Math.floor(n/5);return Z(e,t),s(e,`이벤트: 과중량 (덱 ${n}장 → F +${t})`),"NONE"}}]},{id:"goblin_ambush_low_supplies",name:"매복한 약탈자들",prompt:`고블린들이 보급을 약탈했다.
이번 전투는 보급(S) 5로 시작합니다.`,options:()=>[{key:"fight",label:"맞서 싸운다",detail:"고블린 약탈자 2마리 전투 (S=5 시작)",apply:e=>(e.run.nextBattleSuppliesBonus=-5,{kind:"BATTLE_SPECIAL",title:"고블린 매복",enemyIds:["goblin_raider","goblin_raider"]})}]},{id:"find_adventurer",name:"다른 모험가 발견",prompt:"거래한다.",options:e=>e.run.treasureObtained?[{key:"adventurer:forced_battle",label:"대치한다",detail:"보물을 노리고 덤벼든다.",apply:n=>({kind:"BATTLE_SPECIAL",enemyIds:["other_adventurer"],title:"보물을 노리는 모험가"})}]:[{key:"trade",label:"카드 1장 제거 후 카드 보상(2장 중 1장)",apply:n=>(s(n,"이벤트: 다른 모험가 발견 → 제거할 카드 선택 후 보상"),{kind:"REMOVE_PICK",title:"다른 모험가 발견",prompt:"제거할 카드 1장을 선택하세요.",then:"REWARD_PICK"})},{key:"leave",label:"지나친다",apply:n=>(s(n,"이벤트: 다른 모험가 발견(생략)"),"NONE")}]},{id:"edible_mushroom",name:"식용 버섯 발견",prompt:"기운이 난다. 다음 전투의 시작 보급이 늘어난다.",options:()=>[{key:"eat",label:"F -= 2, 다음 전투 시작 S +5",apply:e=>(e.player.fatigue=Math.max(0,e.player.fatigue-2),e.run.nextBattleSuppliesBonus+=5,s(e,"식용 버섯: F -2, 다음 전투 시작 S +5"),"NONE")}]}],Qe=[{id:"berserk",weight:20},{id:"bandage",weight:12},{id:"arrow_rain",weight:20},{id:"smoke",weight:0},{id:"redeploy",weight:12},{id:"secret_strike",weight:1},{id:"fire_scroll",weight:1},{id:"caltrops",weight:12},{id:"emergency_rations",weight:1},{id:"painkiller",weight:1},{id:"field_experience",weight:1},{id:"camp_prep",weight:20},{id:"vital_shot",weight:12},{id:"taunt",weight:12},{id:"rapid_fire",weight:12}];function qe(e){const n=new Map;for(const t of e){const a=Math.max(0,t.weight??0);a<=0||n.set(t.id,(n.get(t.id)??0)+a)}return[...n.entries()].map(([t,a])=>({id:t,w:a}))}function me(e){let n=0;for(const a of e)n+=a.w;if(n<=0)throw new Error("No positive weights to pick from.");let t=Math.random()*n;for(const a of e)if(t-=a.w,t<=0)return a.id;return e[e.length-1].id}function be(){return Math.random()<.1?1:0}function ue(){const e=qe(Qe),n=me(e),t=e.filter(r=>r.id!==n),a=me(t);return[{defId:n,upgrade:be()},{defId:a,upgrade:be()}]}function Ye(e){return e.uidSeq+=1,`c_${e.uidSeq}`}function oe(e,n,t){const a=Ye(e);e.cards[a]={uid:a,defId:n,zone:"deck",upgrade:t?.upgrade??0},e.deck.push(a)}const Ge="goal_treasure";function Je(e,n){const t=e.cards[n];if(t){if(t.defId===Ge){s(e,"저주받은 보물은 덱에서 제거할 수 없습니다.");return}e.deck=e.deck.filter(a=>a!==n),e.hand=e.hand.filter(a=>a!==n),e.discard=e.discard.filter(a=>a!==n),e.frontSlots=e.frontSlots.map(a=>a===n?null:a),e.backSlots=e.backSlots.map(a=>a===n?null:a),t.zone="vanished",e.vanished.push(n),s(e,`카드 제거: [${w(e,t.uid).name} +${e.cards[t.uid].upgrade??0}]`)}}function Ie(e,n){const t=e.cards[n];if(!t)return!1;const r=e.content.cardsById[t.defId].upgrades?.length??0;return(t.upgrade??0)<r}function Ze(e,n){return Ie(e,n)?(e.cards[n].upgrade=(e.cards[n].upgrade??0)+1,!0):!1}function ge(){return{cardsById:Fe,enemiesById:Ue}}function en(e,n){const t={kind:"damageSelect",amount:n};e.pendingTarget==null?e.pendingTarget=t:e.pendingTargetQueue.push(t);const a=(e.pendingTarget?1:0)+e.pendingTargetQueue.length;s(e,`대상 선택 필요: 적을 클릭하세요. (남은 선택 ${a})`)}function nn(e,n,t){const a={kind:"statusSelect",key:n,n:t};e.pendingTarget==null?e.pendingTarget=a:e.pendingTargetQueue.push(a);const r=(e.pendingTarget?1:0)+e.pendingTargetQueue.length;s(e,`대상 선택 필요: 적을 클릭하세요. (남은 선택 ${r})`)}function tn(e,n){const t=e.content.enemiesById[n.id];return t.intents[n.intentIndex%t.intents.length].acts.some(r=>r.op==="damagePlayer"||r.op==="damagePlayerFormula")}function X(e,n){const t=e.game;for(const a of n)switch(a.op){case"block":Ke(t,a.n);break;case"supplies":ze(t,a.n);break;case"fatigue":Z(t,a.n);break;case"heal":Ve(t,a.n);break;case"hp":t.player.hp=Math.max(0,Math.min(t.player.maxHp,t.player.hp+a.n)),s(t,`HP ${a.n>=0?"+":""}${a.n} (현재 ${t.player.hp}/${t.player.maxHp})`);break;case"maxHp":t.player.maxHp+=a.n,t.player.hp=Math.min(t.player.maxHp,t.player.hp+a.n),s(t,`최대 HP +${a.n} (현재 ${t.player.hp}/${t.player.maxHp})`);break;case"setSupplies":t.player.supplies=Math.max(0,a.n),s(t,`보급 S를 ${t.player.supplies}으로 설정`);break;case"draw":{const r=fe(t,a.n);t.drawCountThisTurn+=r;break}case"ifDrewThisTurn":{t.drawCountThisTurn>0&&X(e,a.then);break}case"damageEnemy":if(a.target==="random"){const r=P(t);if(r.length===0)break;M(t,O(r),a.n)}else if(a.target==="all")for(const r of P(t))M(t,r,a.n);else en(t,a.n);break;case"clearStatusSelf":{const r=a.key;t.player.status[r]=0,s(t,`상태 해제: ${r} = 0`);break}case"damageEnemyBy":{if(a.target!=="random")break;const r=P(t);if(r.length===0)break;let o=0;a.by==="frontCount"&&(o=t.frontSlots.filter(Boolean).length*a.nPer),M(t,O(r),o);break}case"damageEnemyByPlayerFatigue":{const r=Math.max(0,t.player.fatigue*a.mult);if(a.target==="random"){const o=P(t);if(o.length===0)break;M(t,O(o),r);break}if(a.target==="select"){if(r<=0)break;t.pendingTargetQueue.push({kind:"damageSelect",amount:r}),t.pendingTarget=t.pendingTarget??t.pendingTargetQueue.shift()??null;break}break}case"statusPlayer":t.player.status[a.key]=Math.max(0,(t.player.status[a.key]??0)+a.n),s(t,`플레이어 상태: ${a.key} ${a.n>=0?"+":""}${a.n}`);break;case"statusEnemy":if(a.target==="random"){const r=P(t);if(r.length===0)break;const o=O(r);de(o,a.key,a.n),s(t,`적(${o.name}) 상태: ${a.key} ${a.n>=0?"+":""}${a.n}`)}else if(a.target==="all"){const r=P(t);if(r.length===0)break;for(const o of r)de(o,a.key,a.n);s(t,`모든 적 상태: ${a.key} ${a.n>=0?"+":""}${a.n}`)}else nn(t,a.key,a.n);break;case"statusEnemiesAttackingThisTurn":{const r=P(t).filter(o=>tn(t,o));if(r.length===0){s(t,`이번 턴 공격 의도 적 없음 → ${a.key} 적용 없음`);break}for(const o of r)o.status[a.key]=Math.max(0,(o.status[a.key]??0)+a.n);s(t,`공격 의도 적에게 ${a.key} ${a.n>=0?"+":""}${a.n} (대상 ${r.length})`);break}case"immuneDisruptThisTurn":t.player.immuneToDisruptThisTurn=!0,s(t,"이번 턴 교란 무시");break;case"nullifyDamageThisTurn":t.player.nullifyDamageThisTurn=!0,s(t,"이번 턴 피해 무효");break;case"triggerFrontOfBackSlot":{const r=t.backSlots[a.index];if(!r){s(t,`재배치: 후열 ${a.index+1}번 슬롯이 비어 있음`);break}const o=w(t,r);s(t,`재배치: [[${I(t,r)}]]의 전열 효과를 추가 발동`),X({game:t},o.front);break}default:return a}}function se(e,n){const t=e.content.enemiesById[n];return{id:t.id,name:t.name,hp:t.maxHp,maxHp:t.maxHp,intentIndex:0,status:{vuln:0,weak:0,bleed:0,disrupt:0},immuneThisTurn:!1,immuneNextTurn:!1,soulWarnCount:n==="boss_soul_stealer"?0:void 0,soulArmed:n==="boss_soul_stealer"?!1:void 0,soulWillNukeThisTurn:n==="boss_soul_stealer"?!1:void 0}}function an(e,n,t,a=5){for(const r of n){const o=e.run.enemyLastSeenBattle[r];if(o!=null&&t-o<a)return!1}return!0}function G(e,n){const t=n?.forceBoss??!1,a=e.run.nodePickCount,r=e.run.battleCount+1;if(n?.forcePatternIds&&n.forcePatternIds.length>0){const p=n.forcePatternIds;e.run.battleCount=r;for(const b of p)e.run.enemyLastSeenBattle[b]=r;e.enemies=p.map(b=>se(e,b)),s(e,`전투 시작! (노드 ${a}, 전투 ${r}회차) 적: ${e.enemies.map(b=>b.name).join(", ")}`);return}if(t)if(e.run.bossPool.length===0)s(e,`보스 풀이 비었습니다. 일반 전투로 진행합니다. (노드 ${a})`);else{const p=O(e.run.bossPool);e.run.bossPool=e.run.bossPool.filter(b=>b!==p),e.run.battleCount=r,e.run.enemyLastSeenBattle[p]=r,e.enemies=[se(e,p)],s(e,`보스 등장! (노드 ${a}, 전투 ${r}회차) 적: ${e.enemies[0].name}`);return}const o=[[["goblin_raider"],["watching_statue"],["pebble_golem"],["slime"]],[["goblin_raider","slime"],["pebble_golem","pebble_golem"],["rock_golem"],["goblin_raider","goblin_raider"],["poison_spider"]],[["goblin_raider","goblin_raider","goblin_raider"],["pebble_golem","pebble_golem","slime"],["rock_golem","pebble_golem"],["slime","slime"],["poison_spider","slime"]]],l=Math.min(o.length-1,Math.floor((a-1)/10)),f=o[l],u=5,c=f.filter(p=>an(e,p,r,u)),d=c.length>0?c:f,h=O(d);e.run.battleCount=r;for(const p of h)e.run.enemyLastSeenBattle[p]=r;e.enemies=h.map(p=>se(e,p)),s(e,`전투 시작! (노드 ${a}, 전투 ${r}회차) 적: ${e.enemies.map(p=>p.name).join(", ")}`)}function J(e){e.phase="REVEAL",e.frontSlots=[null,null,null],e.backSlots=[null,null,null],e.backSlotDisabled=[!1,!1,!1],e.backUidsThisTurn=[],e.hand=[],e.selectedHandCardUid=null,e.pendingTarget=null,e.pendingTargetQueue=[],e.usedThisTurn=0,e.winHooksAppliedThisCombat=!1;const n=e.run.nextBattleSuppliesBonus??0;e.player.supplies=10+n,n>0&&(s(e,`다음 전투 보너스 적용: S +${n}`),e.run.nextBattleSuppliesBonus=0),e.player.immuneToDisruptThisTurn=!1,e.player.nullifyDamageThisTurn=!1,e.intentsRevealedThisTurn=!1,e.disruptIndexThisTurn=null,e.drawCountThisTurn=0,e.attackedEnemyIndicesThisTurn=[],e.frontPlacedThisTurn=0,e.usedThisTurn=0,fe(e,4),ce(e),e.phase="PLACE"}const rn=2,on=.6;function ce(e){if(e.intentsRevealedThisTurn)return;e.intentsRevealedThisTurn=!0,e.attackedEnemyIndicesThisTurn=[],e.backUidsThisTurn=[],e.drawCountThisTurn=0,e.phase="REVEAL",e.player.immuneToDisruptThisTurn=!1,e.player.nullifyDamageThisTurn=!1,e.disruptIndexThisTurn=null,e.backSlotDisabled=[!1,!1,!1],(e.player.status.disrupt??0)>0&&(e.disruptIndexThisTurn=Math.floor(Math.random()*3),e.backSlotDisabled[e.disruptIndexThisTurn]=!0);for(const t of e.enemies)t.immuneThisTurn=t.immuneNextTurn,t.immuneNextTurn=!1;for(const t of P(e)){const a=e.content.enemiesById[t.id],r=a.intents.length;if(r<=0)continue;if(t.intentIndex=Math.floor(Math.random()*r),t.id==="boss_soul_stealer"){t.soulWillNukeThisTurn=!1;const l=t.soulWarnCount??0;if(!!t.soulArmed){if(Math.random()<on){t.soulWillNukeThisTurn=!0,s(e,`적 의도: ${t.name} → 영혼 폭발 (50 피해!)`);continue}t.intentIndex=Math.floor(Math.random()*r);const c=a.intents[t.intentIndex];s(e,`적 의도: ${t.name} → ${c.label} (⚠ 폭발 가능 상태)`);continue}t.intentIndex=Math.floor(Math.random()*r);const u=a.intents[t.intentIndex];s(e,`적 의도: ${t.name} → ${u.label} (경고 ${l}/3)`);continue}const o=a.intents[t.intentIndex];s(e,`적 의도: ${t.name} → ${o.label}`)}e.disruptIndexThisTurn!==null&&s(e,`교란: 이번 턴 후열 ${e.disruptIndexThisTurn} 무효`),e.phase="PLACE"}function sn(e,n,t,a){if(e.phase!=="PLACE"||!e.hand.includes(n))return;t==="back"&&(e.backUidsThisTurn.includes(n)||e.backUidsThisTurn.push(n));const r=t==="front"?e.frontSlots:e.backSlots;r[a]||(e.hand=e.hand.filter(o=>o!==n),r[a]=n,e.cards[n].zone=t,e.usedThisTurn+=1,s(e,`[${I(e,n)}]를 ${t==="front"?"전열":"후열"} ${a}번에 배치`),t==="front"&&(e.frontPlacedThisTurn+=1))}function ke(e,n,t){return w(e,n).tags?.includes(t)??!1}function ln(e,n){e.frontSlots=e.frontSlots.map(t=>t===n?null:t),e.backSlots=e.backSlots.map(t=>t===n?null:t)}function ee(e,n,t){const a=w(e,n);ln(e,n),e.hand=e.hand.filter(l=>l!==n),e.deck=e.deck.filter(l=>l!==n),e.discard=e.discard.filter(l=>l!==n);const r=a.vanishWhen==="BOTH"||a.vanishWhen==="FRONT"&&t==="front"||a.vanishWhen==="BACK"&&t==="back",o=a.exhaustWhen==="BOTH"||a.exhaustWhen==="FRONT"&&t==="front"||a.exhaustWhen==="BACK"&&t==="back";if(a.vanishWhen&&r){e.vanished.push(n),e.cards[n].zone="vanished",s(e,`[${I(e,n)}] 소실(영구 제거)`);return}if(a.exhaustWhen&&o){e.exhausted.push(n),e.cards[n].zone="exhausted",s(e,`[${I(e,n)}] 소모(이번 전투에서 제거)`);return}if(!a.vanishWhen&&ke(e,n,"VANISH")){e.vanished.push(n),e.cards[n].zone="vanished",s(e,`[${I(e,n)}] 소실(영구 제거)`);return}if(!a.exhaustWhen&&ke(e,n,"EXHAUST")){e.exhausted.push(n),e.cards[n].zone="exhausted",s(e,`[[${I(e,n)}]] 소모(이번 전투에서 제거)`);return}e.discard.push(n),e.cards[n].zone="discard"}function dn(e){for(let n=0;n<3;n++){const t=e.frontSlots[n];t&&ee(e,t,"front"),e.frontSlots[n]=null;const a=e.backSlots[n];a&&ee(e,a,"back"),e.backSlots[n]=null}}function un(e){if(!(e.phase!=="PLACE"&&e.phase!=="BACK")){e.phase="BACK",s(e,"=== 후열 단계 ===");for(let n=0;n<3;n++){const t=e.backSlots[n];if(!t)continue;const a=w(e,t);if(!e.player.immuneToDisruptThisTurn&&e.backSlotDisabled[n]){s(e,`후열 ${n}번 [${a.name}] 교란으로 무효`);continue}X({game:e},a.back),ee(e,t,"back")}e.phase="FRONT"}}function pn(e){if(e.phase==="FRONT"){s(e,"=== 전열 단계 ===");for(let n=0;n<3;n++){const t=e.frontSlots[n];if(!t)continue;const a=w(e,t);X({game:e},a.front),ee(e,t,"front")}e.phase="ENEMY"}}function cn(e){if(e.phase==="ENEMY"){s(e,"=== 적 행동 ===");for(const n of P(e)){const t=e.content.enemiesById[n.id],a=t.intents[n.intentIndex%t.intents.length];if(n.id==="boss_soul_stealer"){if(n.soulWillNukeThisTurn){g(e,50,n),s(e,"영혼 강탈자: 영혼 폭발 → 50 피해!"),n.soulWillNukeThisTurn=!1,n.soulArmed=!1,n.soulWarnCount=0;continue}for(const r of a.acts)Te(e,n,r);n.intentIndex===rn&&(n.soulWarnCount=(n.soulWarnCount??0)+1,s(e,`영혼 강탈자: 경고 +1 (${n.soulWarnCount}/3)`),(n.soulWarnCount??0)>=3&&(n.soulArmed=!0,s(e,"영혼 강탈자: 경고 3회 완료 → 폭발 가능 상태!")));continue}for(const r of a.acts)Te(e,n,r)}e.phase="UPKEEP"}}function Te(e,n,t){switch(t.op){case"damagePlayer":g(e,t.n,n);break;case"damagePlayerFormula":if(t.kind==="goblin_raider"){const a=Math.max(0,12-e.usedThisTurn);g(e,a,n),s(e,`고블린 약탈자: 12 - 사용 ${e.usedThisTurn}장 = ${a} 피해`)}else{const a=4+e.usedThisTurn;g(e,a,n)}break;case"supplies":e.player.supplies=ne(e.player.supplies+t.n,0),s(e,`적 효과: 보급 S ${t.n>=0?"+":""}${t.n} (현재 ${e.player.supplies})`);break;case"statusPlayer":De(e.player,t.key,t.n),s(e,`적 효과: 플레이어 상태 ${t.key} ${t.n>=0?"+":""}${t.n}`);break;case"enemyHealSelf":n.hp=Math.min(n.maxHp,n.hp+t.n),s(e,`적(${n.name})이(가) ${t.n} 회복 (HP ${n.hp}/${n.maxHp})`);break;case"enemyImmuneThisTurn":n.immuneThisTurn=!0,s(e,`적(${n.name})이(가) 피해 면역 상태가 됨`);break;case"enemyImmuneNextTurn":n.immuneNextTurn=!0,s(e,`적(${n.name})이(가) 다음 턴 피해 면역 상태가 됨`);break;case"fatiguePlayer":e.player.fatigue=Math.max(0,e.player.fatigue+t.n),s(e,`적 효과: 피로 F ${t.n>=0?"+":""}${t.n} (현재 ${e.player.fatigue})`);break;default:return t}}function fn(e){if(e.phase!=="UPKEEP")return;s(e,"=== 유지비 / 상태 처리 ===");const n=e.frontPlacedThisTurn;n>0&&s(e,`전열 유지비 처리: 전열 ${n}장`);for(let a=0;a<n;a++)e.player.supplies>0?e.player.supplies-=1:(e.player.hp-=3,e.player.hp<0&&(e.player.hp=0),e.player.fatigue+=1,s(e,`전열 유지비 부족: HP -3, F +1 (HP ${e.player.hp}, F ${e.player.fatigue})`));if(e.player.supplies===0){e.player.zeroSupplyTurns+=1;const a=e.player.zeroSupplyTurns;e.player.hp-=a,e.player.hp<0&&(e.player.hp=0),s(e,`S=0 종료 패널티: 누적 ${a}번째 → HP -${a} (HP ${e.player.hp})`)}const t=e.player.status.bleed??0;t>0&&(e.player.hp-=t,e.player.hp<0&&(e.player.hp=0),s(e,`출혈로 HP -${t} (현재 ${e.player.hp}/${e.player.maxHp})`));for(const a of P(e)){const r=a.status.bleed??0;r>0&&(a.immuneThisTurn?s(e,`적(${a.name})은(는) 이번 턴 면역이라 출혈 피해 무시`):(a.hp=Math.max(0,a.hp-r),s(e,`적(${a.name}) 출혈로 HP -${r} (HP ${a.hp}/${a.maxHp})`)))}e.frontPlacedThisTurn=0,hn(e),dn(e),e.phase="DRAW"}function hn(e){const n=["vuln","weak","bleed","disrupt"];for(const t of n)e.player.status[t]>0&&(e.player.status[t]-=1);for(const t of e.enemies)for(const a of n)t.status[a]>0&&(t.status[a]-=1)}function mn(e){if(e.phase!=="DRAW"||(e.intentsRevealedThisTurn=!1,e.disruptIndexThisTurn=null,Tn(e),e.run.finished))return;if(P(e).length===0){e.phase="NODE";return}const n=e.usedThisTurn;e.usedThisTurn=0,fe(e,n),e.player.block>0&&(e.player.block=0,s(e,"방어(블록) 소실")),ce(e)}function fe(e,n){let t=0;for(let a=0;a<n;a++){bn(e);const r=e.deck.pop();if(!r)break;e.hand.push(r),t++}return s(e,`드로우 ${t}/${n} (손패 ${e.hand.length})`),t}function bn(e){if(e.deck.length===0&&e.discard.length>0){e.deck=Se(e.discard),e.discard=[];const n=e.player.fatigue;n>0?(e.player.hp-=n,e.player.hp<0&&(e.player.hp=0),s(e,`리셔플 피로: HP -${n} (F=${n})`)):s(e,"리셔플: 피로 피해 없음 (F=0)"),e.player.fatigue+=1,s(e,`피로 F +1 (현재 ${e.player.fatigue})`)}}function kn(e,n){if(!e.pendingTarget)return;if(P(e).length===0){e.pendingTarget=null,e.pendingTargetQueue=[];return}const t=e.enemies[n];if(!t||t.hp<=0)return;const a=e.pendingTarget;a.kind==="damageSelect"?M(e,t,a.amount):a.kind==="statusSelect"&&(de(t,a.key,a.n),s(e,`적(${t.name}) 상태: ${a.key} ${a.n>=0?"+":""}${a.n}`)),e.pendingTarget=e.pendingTargetQueue.shift()??null}function Tn(e){if(e.player.hp<=0){e.run.finished=!0,s(e,"패배: 플레이어 HP가 0 이하");return}if(P(e).length===0&&e.phase!=="NODE"){if(En(e),s(e,"승리: 적을 모두 처치!"),yn(e),e.player.zeroSupplyTurns=0,e.run.treasureObtained&&e.run.afterTreasureNodePicks>=10){e.run.finished=!0,s(e,"승리! 저주받은 보물을 얻은 후 10턴 동안 살아남았습니다.");return}const[n,t]=ue(),a=v(e.content,n.defId,n.upgrade),r=v(e.content,t.defId,t.upgrade),o=n.upgrade>0?`${a.name} +${n.upgrade}`:a.name,l=t.upgrade>0?`${r.name} +${t.upgrade}`:r.name;e.choice={kind:"REWARD",title:"전투 보상",prompt:"두 장 중 한 장을 선택하거나 생략합니다.",options:[{key:`pick:${n.defId}:${n.upgrade}`,label:o,detail:`전열: ${a.frontText} / 후열: ${a.backText}`},{key:`pick:${t.defId}:${t.upgrade}`,label:l,detail:`전열: ${r.frontText} / 후열: ${r.backText}`},{key:"skip",label:"생략"}]};return}}function yn(e){const n=[];for(const o of e.deck)n.push(o);for(const o of e.hand)n.push(o);for(const o of e.discard)n.push(o);for(const o of e.frontSlots)o&&n.push(o);for(const o of e.backSlots)o&&n.push(o);for(const o of e.exhausted)n.push(o);const t=new Set,r=n.filter(o=>t.has(o)?!1:(t.add(o),!0)).filter(o=>e.cards[o]?.zone!=="vanished");e.deck=r;for(const o of r)e.cards[o].zone="deck";e.hand=[],e.discard=[],e.frontSlots=[null,null,null],e.backSlots=[null,null,null],e.selectedHandCardUid=null,e.exhausted=[],e.pendingTarget=null,e.pendingTargetQueue=[],xn(e.deck)}function xn(e){for(let n=e.length-1;n>0;n--){const t=Math.floor(Math.random()*(n+1));[e[n],e[t]]=[e[t],e[n]]}}function En(e){if(!e.winHooksAppliedThisCombat){e.winHooksAppliedThisCombat=!0;for(const n of e.backUidsThisTurn){if(!e.cards[n])continue;const r=w(e,n).onWinWhileInBack;!r||r.length===0||X({game:e},r)}}}const Cn=`# Deck Rogue Prototype — 룰북 (플레이어용)

이 문서는 스포일러를 최소화합니다.

[1] 개요
노드를 선택하며 진행하고, 전투에서 살아남아 성장합니다. 목표는 무엇일까요?
모든 카드는 전열과 후열이 있습니다. 배치에 따라 역할이 달라집니다.

[2] 보급과 피로도

보급(S): 전열 카드 및 일부 효과의 발동에 사용됩니다. 보통 10으로 시작합니다.
보급이 부족한 상태로 턴 종료 시, HP를 보급 없이 종료한 턴의 횟수만큼 잃습니다.

피로도(F): 덱을 섞을 때 피로도가 1 올라가며, 일부 카드의 효과로도 변합니다.
덱을 섞을 때 피로도만큼 피해를 입습니다. 피로도는 전투가 끝나도 유지됩니다.

보급이 부족한 채로 턴을 마칠 때, 사용한 전열 카드 한 장 당 HP를 3 잃으며, F가 1 증가합니다.
이 효과는 보급 자체에 의한 HP 손실과 별개입니다!

[3] 전투 흐름
배치 → 후열 발동 → 전열 발동 → 적 행동 → 정리 → 드로우
※ “대상 선택 필요”가 뜨면 살아있는 적을 클릭해 대상을 정하세요.
※ 후열 발동을 누르면 턴이 진행되어, 카드의 배치를 변경할 수 없습니다.
보급 및 그에 따른 변화는 정리 단계에서 처리합니다.

손패는 턴이 종료되어도 유지됩니다.
카드는 매 턴마다 사용한 만큼 뽑습니다. 즉, 카드로 인한 드로우는 패의 매수 자체를 늘리는 효과가 있습니다.

[4] 용어
- 소모: 이번 전투에서 사용할 수 없게 되는 것입니다.
- 소실: 런 전체에서 해당 카드가 사라지는 것입니다.
- 취약: 받는 피해가 (취약)만큼 증가합니다.
- 약화: 주는 피해가 (약화)만큼 감소합니다.
- 출혈: 턴 종료 시 (출혈)만큼 피해를 입습니다.
- 교란: 당신을 방해합니다. 무엇일까요?

[6] 조작
- Esc: 선택 해제
- Tab: 손패 선택 이동
- 1~3: 전열 배치 / Shift+1~3: 후열 배치
- 드래그: 손패→슬롯 배치, 슬롯↔슬롯 스왑, 슬롯→손패 회수
`;let U=!1,N=null,le=[],ye=!1,m=null,K=null;function He(e,n){let t=null;const a={rerender:()=>i(e,a),onToggleLog:()=>{U=!U,i(e,a)},onCloseOverlay:()=>{N=le.pop()??null,i(e,a)},onNewRun:()=>{const r=Pe(e.content);n(r)},onViewRulebook:()=>{N&&le.push(N),N={kind:"RULEBOOK"},i(e,a)},onReturnSlotToHand:(r,o)=>{if(e.run.finished||R(e)||e.phase!=="PLACE")return;const l=r==="front"?e.frontSlots:e.backSlots,f=l[o];f&&(l[o]=null,e.hand.push(f),e.cards[f].zone="hand",s(e,`[${I(e,f)}] 회수: ${r}${o+1} → 손패`),i(e,a))},onClearSelected:()=>{e.selectedHandCardUid=null,i(e,a)},onSelectHandCard:r=>{R(e)||(e.selectedHandCardUid=e.selectedHandCardUid===r?null:r,i(e,a))},onViewPile:r=>{N&&le.push(N),N={kind:"PILE",pile:r},i(e,a)},getNodeOffers:()=>(e.run.branchOffer||(e.run.branchOffer=V(e)),(e.run.nodePickCount+1)%30===0?[{id:"A",type:"BATTLE"},{id:"B",type:"BATTLE"}]:e.run.branchOffer.root),onChooseNode:r=>{if(e.run.finished)return;if(e.phase!=="NODE"){s(e,`무시: 전투/진행 중 노드 선택 시도 (phase=${e.phase})`);return}e.run.branchOffer||(e.run.branchOffer=V(e));const o=e.run.nodePickCount+1,l=o%30===0,u=l?"BATTLE":r==="A"?e.run.branchOffer.root[0].type:e.run.branchOffer.root[1].type;if(e.run.nodePickCount=o,e.run.nodePickByType[u]=(e.run.nodePickByType[u]??0)+1,Re(e,r),e.run.treasureObtained&&u!=="TREASURE"&&(e.run.afterTreasureNodePicks+=1,e.run.afterTreasureNodePicks>=10)){e.run.finished=!0,s(e,"승리! 저주받은 보물을 얻은 후 10번의 탐험을 버텼습니다."),i(e,a);return}if(u==="BATTLE"){l&&s(e,`=== ${o}번째 노드: 보스 전투 ===`),G(e,{forceBoss:l}),J(e),i(e,a);return}if(u==="REST"){const c=()=>{e.choice={kind:"EVENT",title:"휴식",prompt:"무엇을 하시겠습니까?",options:[{key:"rest:heal",label:"HP +15"},{key:"rest:clear_f",label:"F -3"},{key:"rest:upgrade",label:"카드 강화 (+1)"},{key:"rest:skip",label:"생략"}]},t=h=>{if(h==="rest:heal"){e.player.hp=Math.min(e.player.maxHp,e.player.hp+15),s(e,"휴식: HP +15"),e.choice=null,t=null,i(e,a);return}if(h==="rest:clear_f"){e.player.fatigue=Math.max(0,e.player.fatigue-3),s(e,"휴식: 피로 F-=3"),e.choice=null,t=null,i(e,a);return}if(h==="rest:upgrade"){d();return}s(e,"휴식: 생략"),e.choice=null,t=null,i(e,a)}},d=()=>{const h=Object.values(e.cards).filter(p=>p.zone==="deck"||p.zone==="hand"||p.zone==="discard").map(p=>p.uid).filter(p=>Ie(e,p));if(h.length===0){s(e,"강화할 수 있는 카드가 없습니다."),c(),i(e,a);return}e.choice={kind:"PICK_CARD",title:"카드 강화",prompt:"강화할 카드 1장을 선택하세요.",options:[...h.map(p=>({key:`upgrade:${p}`,label:Dn(e,p),detail:vn(e,p),cardUid:p})),{key:"cancel",label:"취소"}]},t=p=>{if(p==="cancel"){c(),i(e,a);return}if(!p.startsWith("upgrade:"))return;const b=p.slice(8);Ze(e,b)?s(e,`강화 완료: ${I(e,b)}`):s(e,"강화 실패(최대 강화/대상 없음)"),e.choice=null,t=null,i(e,a)},i(e,a)};c(),i(e,a);return}if(u==="TREASURE"){e.run.treasureObtained=!0,e.run.afterTreasureNodePicks=0,s(e,"저주받은 보물을 얻었습니다! 이제부터 10번의 탐험을 버티면 승리합니다."),i(e,a);return}if(u==="EVENT"){const c=je(),d=c.options(e);e.choice={kind:"EVENT",title:c.name,prompt:c.prompt,options:d.map(h=>({key:h.key,label:h.label,detail:h.detail}))},t=h=>{const p=d.find($=>$.key===h);if(!p)return;const b=p.apply(e);if(typeof b=="object"&&b.kind==="REMOVE_PICK"){const $=Object.values(e.cards).filter(T=>T.zone==="deck"||T.zone==="hand"||T.zone==="discard").map(T=>T.uid);e.choice={kind:"PICK_CARD",title:b.title,prompt:b.prompt??"제거할 카드 1장을 선택하세요.",options:[...$.map(T=>{const k=w(e,T);return{key:`remove:${T}`,label:I(e,T),detail:`전열: ${k.frontText} / 후열: ${k.backText}`,cardUid:T}}),{key:"cancel",label:"취소"}]},t=T=>{if(T==="cancel"){e.choice=null,t=null,i(e,a);return}if(!T.startsWith("remove:")){i(e,a);return}const k=T.slice(7);if(Je(e,k),b.then==="BATTLE"){e.choice=null,t=null,G(e),J(e),i(e,a);return}if(b.then==="REWARD_PICK"){const[x,E]=ue(),B=v(e.content,x.defId,x.upgrade),A=v(e.content,E.defId,E.upgrade),W=x.upgrade>0?`${B.name} +${x.upgrade}`:B.name,_=E.upgrade>0?`${A.name} +${E.upgrade}`:A.name;e.choice={kind:"REWARD",title:"카드 보상",prompt:"두 장 중 한 장을 선택하거나 생략합니다.",options:[{key:`pick:${x.defId}:${x.upgrade}`,label:W,detail:`전열: ${B.frontText} / 후열: ${B.backText}`},{key:`pick:${E.defId}:${E.upgrade}`,label:_,detail:`전열: ${A.frontText} / 후열: ${A.backText}`},{key:"skip",label:"생략"}]},t=H=>{if(H.startsWith("pick:")){const[,Q,te]=H.split(":"),q=Number(te??"0")||0;oe(e,Q,{upgrade:q})}else s(e,"카드 보상 생략");e.choice=null,t=null,i(e,a)},i(e,a);return}e.choice=null,t=null,i(e,a)},i(e,a);return}if(typeof b=="object"&&b.kind==="BATTLE_SPECIAL"){e.choice=null,t=null,s(e,b.title?`이벤트 전투: ${b.title}`:"이벤트 전투 발생!"),G(e,{forcePatternIds:b.enemyIds}),J(e),i(e,a);return}if(b==="BATTLE"){e.choice=null,t=null,G(e),J(e),i(e,a);return}if(b==="REWARD_PICK"){const[$,T]=ue(),k=v(e.content,$.defId,$.upgrade),x=v(e.content,T.defId,T.upgrade),E=$.upgrade>0?`${k.name} +${$.upgrade}`:k.name,B=T.upgrade>0?`${x.name} +${T.upgrade}`:x.name;e.choice={kind:"REWARD",title:"카드 보상",prompt:"두 장 중 한 장을 선택하거나 생략합니다.",options:[{key:`pick:${$.defId}:${$.upgrade}`,label:E,detail:`전열: ${k.frontText} / 후열: ${k.backText}`},{key:`pick:${T.defId}:${T.upgrade}`,label:B,detail:`전열: ${x.frontText} / 후열: ${x.backText}`},{key:"skip",label:"생략"}]},t=A=>{if(A.startsWith("pick:")){const[,W,_]=A.split(":"),H=Number(_??"0")||0;oe(e,W,{upgrade:H})}else s(e,"카드 보상 생략");e.choice=null,t=null,i(e,a)},i(e,a);return}e.choice=null,t=null,i(e,a)},i(e,a);return}},onChooseChoice:r=>{if(e.choice){if(t){t(r);return}if(e.choice.kind==="REWARD"){if(r==="skip")s(e,"카드 보상 생략");else if(r.startsWith("pick:")){const[,o,l]=r.split(":"),f=Number(l??"0")||0;oe(e,o,{upgrade:f})}e.choice=null,e.phase="NODE",i(e,a);return}}},onRevealIntents:()=>{e.run.finished||e.enemies.length!==0&&(ce(e),i(e,a))},onSelectEnemy:r=>{kn(e,r),i(e,a)},onPlaceHandUidToSlot:(r,o,l)=>{e.run.finished||R(e)||e.phase==="PLACE"&&(o==="back"&&e.backSlotDisabled?.[l]||(sn(e,r,o,l),e.selectedHandCardUid=null,i(e,a)))},onPlaceSelected:(r,o)=>{e.selectedHandCardUid&&a.onPlaceHandUidToSlot(e.selectedHandCardUid,r,o)},onMoveSlotCard:(r,o,l,f)=>{if(e.run.finished||R(e)||e.phase!=="PLACE"||l==="back"&&e.backSlotDisabled?.[f])return;const u=r==="front"?e.frontSlots:e.backSlots,c=l==="front"?e.frontSlots:e.backSlots,d=u[o];if(!d)return;const h=c[f];u[o]=h??null,c[f]=d,e.cards[d].zone=l,h&&(e.cards[h].zone=r);const p=I(e,d),b=h?I(e,h):null;s(e,h?`[${p}] ↔ [${b}] 스왑: ${r}${o+1} ↔ ${l}${f+1}`:`[${p}] 이동: ${r}${o+1} → ${l}${f+1}`),i(e,a)},onResolveBack:()=>{un(e),i(e,a)},onResolveFront:()=>{pn(e),i(e,a)},onResolveEnemy:()=>{cn(e),i(e,a)},onUpkeep:()=>{fn(e),i(e,a)},onDrawNextTurn:()=>{mn(e),i(e,a)}};return a}function $n(){const e=document.querySelector("#app");return e.innerHTML="",e}function i(e,n){const t=$n();ye||(Pn(t,e,n),ye=!0);const a=y("row top"),r=y("panel"),o=y("panel");r.appendChild(ie("상태")),r.appendChild(Bn(e)),r.appendChild(j()),r.appendChild(L("플레이어 상태")),r.appendChild(Nn(e.player.status));const l=y("controls");l.appendChild(C("덱",()=>n.onViewPile("deck"),!1)),l.appendChild(C("버림",()=>n.onViewPile("discard"),!1)),l.appendChild(C("소모",()=>n.onViewPile("exhausted"),!1)),l.appendChild(C("소실",()=>n.onViewPile("vanished"),!1)),l.appendChild(C("손패",()=>n.onViewPile("hand"),!1)),l.appendChild(C("룰북",n.onViewRulebook,!1)),l.appendChild(C("새 런",n.onNewRun,!1)),r.appendChild(l),r.appendChild(j()),r.appendChild(L("적"));const f=R(e),u=(e.pendingTarget?1:0)+(e.pendingTargetQueue?.length??0);if(e.enemies.length===0)r.appendChild(D("현재 전투 없음"));else{if(f){const k=y("banner banner-left");k.textContent=`대상 선택이 필요합니다. (남은 선택 ${u})`,r.appendChild(k)}const b=e.enemies.map((k,x)=>({e:k,i:x})).filter(({e:k})=>k.hp>0),$=e.enemies.map((k,x)=>({e:k,i:x})).filter(({e:k})=>k.hp<=0),T=[...b,...$];for(const{e:k,i:x}of T){const E=y("enemyBox");E.dataset.enemyIndex=String(x);const B=k.hp>0,A=f&&B;A&&E.classList.add("targetable"),B||E.classList.add("dead");const W=D(`${x+1}. ${k.name} (HP ${k.hp}/${k.maxHp})`);W.className="enemyTitle",E.appendChild(W);const _=y("badgesRow");k.immuneThisTurn&&_.appendChild(S("면역 ✨")),B||_.appendChild(S("DEAD"));const H=k.status;(H.vuln??0)>0&&_.appendChild(S(`취약 ${H.vuln}`)),(H.weak??0)>0&&_.appendChild(S(`약화 ${H.weak}`)),(H.bleed??0)>0&&_.appendChild(S(`출혈 ${H.bleed}`)),(H.disrupt??0)>0&&_.appendChild(S(`교란 ${H.disrupt}`)),_.childNodes.length>0&&E.appendChild(_);const Q=e.content.enemiesById[k.id],te=Q.intents[k.intentIndex%Q.intents.length],q=D(e.intentsRevealedThisTurn?`의도: ${te.label}`:"의도: (미공개)");q.className=e.intentsRevealedThisTurn?"intentOn":"intentOff",E.appendChild(q);const Y=document.createElement("button");Y.textContent=A?"이 적을 선택":"대상 선택",Y.disabled=!A,Y.onclick=()=>n.onSelectEnemy(x),E.appendChild(Y),r.appendChild(E)}}if(o.appendChild(ie("진행")),f){const b=y("banner banner-target");b.textContent=`⚠ 대상 선택 필요 (남은 선택 ${u}) — 왼쪽에서 살아있는 적을 고르세요.`,o.appendChild(b)}e.run.finished?o.appendChild(D("런 종료")):N?Rn(o,e,n,N):e.choice?_n(o,e,n):e.phase==="NODE"?An(o,e,n):Sn(o,e,n,f),a.appendChild(r),a.appendChild(o);const c=y("panel logPanel"+(U?" collapsed":"")),d=y("row");d.style.gridTemplateColumns="1fr auto",d.style.alignItems="center",d.appendChild(ie("로그"));const p=C(U?"로그 펼치기":"로그 접기",n.onToggleLog,!1);p.classList.add("primary"),d.appendChild(p),c.appendChild(d),U||c.appendChild(On(e.log.join(`
`))),t.appendChild(a),t.appendChild(c),wn(t,e)}function Sn(e,n,t,a){const r=y("controls combatControls");r.appendChild(C("의도 공개(정찰)",t.onRevealIntents,n.enemies.length===0||n.intentsRevealedThisTurn||n.phase!=="PLACE"||a)),r.appendChild(C("후열 발동",t.onResolveBack,!(n.phase==="PLACE"||n.phase==="BACK")||a)),r.appendChild(C("전열 발동",t.onResolveFront,n.phase!=="FRONT"||a)),r.appendChild(C("적 행동",t.onResolveEnemy,n.phase!=="ENEMY"||a)),r.appendChild(C("턴 정리",t.onUpkeep,n.phase!=="UPKEEP"||a)),r.appendChild(C("드로우",t.onDrawNextTurn,n.phase!=="DRAW"||a)),r.appendChild(C("선택 해제(Esc)",t.onClearSelected,!n.selectedHandCardUid)),e.appendChild(r),e.appendChild(j()),e.appendChild(L("전열 슬롯 (1~3)")),e.appendChild(xe(n,t,"front")),e.appendChild(L("후열 슬롯 (Shift+1~3)")),e.appendChild(xe(n,t,"back")),e.appendChild(j()),e.appendChild(L(`손패 (${n.hand.length}) — Tab로 선택 이동`));const o=y("hand");o.dataset.dropHand="1";for(const f of n.hand)o.appendChild(Be(n,f,!0,t.onSelectHandCard));e.appendChild(o);const l=Ne("드래그: 손패→슬롯 배치 / 슬롯→슬롯 스왑. 키보드: 1~3 전열, Shift+1~3 후열, Tab 이동, Esc 해제.");l.className="help",e.appendChild(l)}function xe(e,n,t){const a=y("grid6"),r=!!e.selectedHandCardUid,o=t==="front"?e.frontSlots:e.backSlots;for(let l=0;l<3;l++){const f=t==="back"?!!e.backSlotDisabled?.[l]:!1,u=y("slot"+(f?" disabled":""));u.dataset.slotSide=t,u.dataset.slotIndex=String(l),K&&K.side===t&&K.idx===l&&u.classList.add("dropHover"),r&&!f&&u.classList.add("placeable"),u.appendChild(Ne(`${t==="front"?"전열":"후열"} ${l+1}`));const c=o[l];if(c){u.appendChild(Be(e,c,!1));const d=u.querySelector(".card");d&&(d.onpointerdown=h=>{h.button!==0&&h.pointerType==="mouse"||R(e)||e.phase==="PLACE"&&we(h,{kind:"slot",cardUid:c,fromSide:t,fromIdx:l})},d.ondblclick=()=>{n.onReturnSlotToHand(t,l)})}u.onclick=()=>{f||n.onPlaceSelected(t,l)},a.appendChild(u)}return a}function Pn(e,n,t){e.onpointermove=a=>{if(!m||a.pointerId!==m.pointerId)return;m.x=a.clientX,m.y=a.clientY;const r=m.x-m.startX,o=m.y-m.startY;!m.dragging&&r*r+o*o>36&&(m.dragging=!0),K=m.dragging?Ee(a.clientX,a.clientY,n):null,i(n,t)},e.onpointerup=a=>{if(!(!m||a.pointerId!==m.pointerId)){if(m.dragging){const r=Ee(a.clientX,a.clientY,n);r?m.kind==="hand"?t.onPlaceHandUidToSlot(m.cardUid,r.side,r.idx):m.kind==="slot"&&m.fromSide!=null&&m.fromIdx!=null&&(m.fromSide===r.side&&m.fromIdx===r.idx||t.onMoveSlotCard(m.fromSide,m.fromIdx,r.side,r.idx)):m.kind==="slot"&&m.fromSide!=null&&m.fromIdx!=null&&Hn(a.clientX,a.clientY)&&t.onReturnSlotToHand(m.fromSide,m.fromIdx)}m=null,K=null,i(n,t)}},window.addEventListener("keydown",a=>{const r=a.target;if(r&&(r.tagName==="INPUT"||r.tagName==="TEXTAREA"))return;if(R(n)){a.key==="Escape"&&(a.preventDefault(),t.onClearSelected());return}if(a.key==="Escape"){a.preventDefault(),t.onClearSelected();return}if(a.key==="Tab"){if(a.preventDefault(),n.hand.length===0)return;const l=n.selectedHandCardUid,f=l?n.hand.indexOf(l):-1,u=a.shiftKey?-1:1,c=((f+u)%n.hand.length+n.hand.length)%n.hand.length;n.selectedHandCardUid=n.hand[c],i(n,t);return}const o=In(a.code);if(o!=null){if(!n.selectedHandCardUid||n.phase!=="PLACE")return;const l=o-1;a.shiftKey?t.onPlaceSelected("back",l):t.onPlaceSelected("front",l);return}})}function In(e){return e==="Digit1"?1:e==="Digit2"?2:e==="Digit3"?3:null}function we(e,n){e.currentTarget.setPointerCapture(e.pointerId),m={kind:n.kind,cardUid:n.cardUid,fromSide:n.fromSide,fromIdx:n.fromIdx,pointerId:e.pointerId,startX:e.clientX,startY:e.clientY,x:e.clientX,y:e.clientY,dragging:!1}}function Ee(e,n,t){const a=document.elementFromPoint(e,n);if(!a)return null;const r=_e(a,["slotSide","slotIndex"]);if(!r)return null;const o=r.dataset.slotSide,l=Number(r.dataset.slotIndex);return o==="back"&&t.backSlotDisabled?.[l]?null:{side:o,idx:l}}function Hn(e,n){const t=document.elementFromPoint(e,n);return t?!!_e(t,["dropHand"]):!1}function _e(e,n){let t=e;for(;t;){const a=t.dataset;let r=!0;for(const o of n)if(a[o]==null){r=!1;break}if(r)return t;t=t.parentElement}return null}function wn(e,n){if(!m||!m.dragging)return;const t=y("dragGhost");t.textContent=I(n,m.cardUid),t.style.position="fixed",t.style.left=`${m.x+12}px`,t.style.top=`${m.y+12}px`,t.style.pointerEvents="none",t.style.zIndex="9999",e.appendChild(t)}function _n(e,n,t){if(e.appendChild(L(n.choice.title)),n.choice.prompt){const r=document.createElement("pre");r.className="rulebook",r.textContent=n.choice.prompt,e.appendChild(r)}const a=y("controls");for(const r of n.choice.options){const o=document.createElement("button");o.className="primary",o.style.whiteSpace="pre-line",o.textContent=r.detail?`${r.label}
${r.detail}`:r.label,o.onclick=()=>t.onChooseChoice(r.key),a.appendChild(o)}e.appendChild(a)}function Ae(e,n){return e==="BATTLE"?n?"보스":"전투":e==="REST"?"휴식":e==="EVENT"?"이벤트":"저주받은 보물"}function Ce(e,n){return n?"보스":e.map(t=>Ae(t.type,!1)).join(" / ")}function An(e,n,t){const a=[`[선택 ${n.run.nodePickCount}회]`];n.run.treasureObtained&&a.push(`[보물 후 ${n.run.afterTreasureNodePicks}/10]`),e.appendChild(D(a.join(" ")));const o=(n.run.nodePickCount+1)%30===0,l=(n.run.nodePickCount+2)%30===0,f=t.getNodeOffers(),u=n.run.branchOffer;u&&(e.appendChild(D(`전자 선택 시 다음 선택지: ${Ce(u.nextIfA,l)}`)),e.appendChild(D(`후자 선택 시 다음 선택지: ${Ce(u.nextIfB,l)}`)),e.appendChild(j()));const c=y("controls");for(const d of f){const h=document.createElement("button");h.className="primary",h.textContent=Ae(d.type,o),h.onclick=()=>t.onChooseNode(d.id),c.appendChild(h)}e.appendChild(c)}function R(e){return e.pendingTarget!=null||(e.pendingTargetQueue?.length??0)>0}function Bn(e){const n=y("stats");return n.appendChild(S(`HP ❤️ ${e.player.hp}/${e.player.maxHp}`)),n.appendChild(S(`블록 🛡️ ${e.player.block}`)),n.appendChild(S(`S ${e.player.supplies}`)),n.appendChild(S(`F ${e.player.fatigue}`)),n.appendChild(S(`${e.run.nodePickCount}번 탐험`)),n.appendChild(S(`덱 ${e.deck.length}장`)),n}function Nn(e){const n=y("badgesRow");for(const[t,a]of Object.entries(e))a&&n.appendChild(S(`${t} ${a}`));return n}function Be(e,n,t,a){const r=w(e,n),o=y("card");e.selectedHandCardUid===n&&o.classList.add("selected"),r.tags?.includes("EXHAUST")&&o.classList.add("exhaust"),r.tags?.includes("VANISH")&&o.classList.add("vanish"),o.appendChild($e("cardTitle",I(e,n)));const l=y("cardMeta");r.tags?.includes("EXHAUST")&&l.appendChild(S("소모")),r.tags?.includes("VANISH")&&l.appendChild(S("소실")),o.appendChild(l);const f=$e("cardText",`전열: ${r.frontText}
후열: ${r.backText}`);return f.style.whiteSpace="pre-line",o.appendChild(f),t&&a&&(o.onclick=()=>a(n),o.onpointerdown=u=>{u.button!==0&&u.pointerType==="mouse"||R(e)||e.phase==="PLACE"&&we(u,{kind:"hand",cardUid:n})}),o}function y(e){const n=document.createElement("div");return n.className=e,n}function $e(e,n){const t=document.createElement("div");return t.className=e,t.textContent=n,t}function ie(e){const n=document.createElement("h2");return n.textContent=e,n}function L(e){const n=document.createElement("h3");return n.textContent=e,n}function D(e){const n=document.createElement("p");return n.textContent=e,n}function Ne(e){const n=document.createElement("small");return n.textContent=e,n}function j(){return document.createElement("hr")}function S(e){const n=document.createElement("span");return n.className="badge",n.textContent=e,n}function C(e,n,t){const a=document.createElement("button");return a.textContent=e,a.disabled=t,a.onclick=n,a}function On(e){const n=document.createElement("pre");return n.className="log",n.textContent=e,n}function Rn(e,n,t,a){const r=a.kind==="RULEBOOK"?"룰북":a.pile==="deck"?"덱":a.pile==="discard"?"버림 더미":a.pile==="exhausted"?"소모(이번 전투)":a.pile==="vanished"?"소실(영구)":"손패";if(e.appendChild(L(r)),a.kind==="RULEBOOK"){const l=document.createElement("pre");l.className="rulebook",l.textContent=Cn,e.appendChild(l)}else{const f=[...a.pile==="deck"?n.deck:a.pile==="discard"?n.discard:a.pile==="exhausted"?n.exhausted:a.pile==="vanished"?n.vanished:n.hand].sort((c,d)=>{const h=w(n,c),p=w(n,d),b=h.name.localeCompare(p.name,"ko");if(b!==0)return b;const $=n.cards[c].upgrade??0,T=n.cards[d].upgrade??0;return $!==T?T-$:c.localeCompare(d)}),u=y("controls");for(const c of f){const d=w(n,c),h=document.createElement("button");h.className="primary",h.textContent=`${I(n,c)} — 전열: ${d.frontText} / 후열: ${d.backText}`,h.onclick=()=>{},u.appendChild(h)}e.appendChild(u)}const o=y("controls");o.appendChild(C("닫기",t.onCloseOverlay,!1)),e.appendChild(o)}function vn(e,n){const t=e.cards[n],a=(t.upgrade??0)+1,r=v(e.content,t.defId,a);return`
전열: ${r.frontText}
후열: ${r.backText}`}function Dn(e,n){const t=e.cards[n],r=(t.upgrade??0)+1,o=e.content.cardsById[t.defId].name;return r>0?`${o} +${r}`:o}const Ln=ge();let z=Pe(Ln);function Oe(e){z=e,pe=He(z,Oe),i(z,pe)}let pe=He(z,Oe);i(z,pe);
